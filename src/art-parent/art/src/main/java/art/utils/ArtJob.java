/**
 * Copyright 2001-2013 Enrico Liboni <eliboni@users.sourceforge.net>
 *
 * This file is part of ART.
 *
 * ART is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, version 2 of the License.
 *
 * ART is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ART. If not, see <http://www.gnu.org/licenses/>.
 */
/* 2007-02-02  john   added editable subject
 2007-05-14  enrico added new type = 5 (mail with html output inside the email)
 filenamecolumn in ART_JOB enlarged so error message can be fully displayed
 2008-04-04  enrico reworkto use this class as a bean
 and allow to edit/run an existing job
 2008-05-06  enrico fixes to support UTF-8 correctly in generated html files and inline emails
 2009-10-20  enrico  fixed weekday (it was weekDay causing the bean to do not populate it)
 on line 321, 376, 300 replaced charset name UTF8 to UTF-8 (utf-8 inline html should be ok now...
 2010-05-01 enrico/timothy added option to handle charts
 */
package art.utils;

import art.dbutils.DbConnections;
import art.runreport.ReportRunner;
import art.graph.ExportGraph;
import art.mail.Mailer;
import art.output.ReportOutputInterface;
import art.output.JasperReportsOutput;
import art.output.JxlsOutput;
import art.servlets.ArtConfig;
import java.io.*;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.mail.MessagingException;
import org.apache.commons.lang3.StringUtils;
import org.quartz.*;
import static org.quartz.CronScheduleBuilder.cronSchedule;
import static org.quartz.JobBuilder.newJob;
import static org.quartz.JobKey.jobKey;
import static org.quartz.TriggerBuilder.newTrigger;
import static org.quartz.TriggerKey.triggerKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to run scheduled jobs.
 *
 * <br> To run an existing job:
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.start(); // run the job
 * </pre>
 *
 * To delete an existing job
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.delete();
 * </pre>
 *
 * To update an existing job (query parameters can't be updated - delete and
 * recreate if needed)
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.set...
 * ...
 * aj.save()
 * </pre>
 *
 * To create a new job
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.set...
 * ...
 * //params need to be set apart
 * aj.save()
 * </pre>
 *
 */
public class ArtJob implements Job, Serializable {

	private static final long serialVersionUID = 1L; //implement serializable to enable job object in session to be serialized
	private static final Logger logger = LoggerFactory.getLogger(ArtJob.class);
	String username, outputFormat, tos, from, message, queryName, subject;
	String enableAudit = "N";
	String activeStatus = "A";
	int jobId = -1;
	int queryType = 0;
	int queryId;
	int jobType;
	String jobName;
	String cachedTableName;
	String minute = "";
	String hour = "";
	String day = "";
	String weekday = "";
	String month = "";
	java.util.Date nextRunDate;
	java.util.Date startDate; //date from which the job will start running. will default to the current date
	java.util.Date endDate; //date at which the job will stop running. default will be no end
	String startDateString = ""; //for use from editjob.jsp
	String endDateString = ""; //for use from editjob.jsp
	String allowSharing = "N"; //for shared jobs
	String allowSplitting = "N"; //for shared jobs. to determine if user rule values should be applied
	String queryRulesFlag; //to determine whether to generate multiple outputs for shared jobs
	String migratedToQuartz = "X"; //to indicate that this job doesn't need migration to quartz. migration done for jobs created with ART versions before 1.11
	java.util.Date lastStartDate; //last start time of overall job
	java.util.Date sharedLastStartDate; //last start time of split job for a specific user
	java.util.Date lastEndDate; //last end time of overall job
	java.util.Date sharedLastEndDate; //last end time of split job for a specific user
	String sharedFileName; //file name in art_user_jobs table. For split jobs. Unique to the user. Result of applying query rule values for a given user
	// fileName will be set to the filename generated by the job, if any (Alerts do not generate files) or to the generated exception.
	// For cached results this contains the table and columns names
	String fileName = "-No File";
	String parametersDisplayString = ""; //string containing job parameters for display in myjobs.jsp page
	//descriptions to set titles for charts when outputting charts to file
	String queryShortDescription;
	String xAxisLabel;
	String yAxisLabel;
	String queryGraphOptions; //graph options defined for the query
	//
	Map<String, String[]> multiParams;
	Map<String, String> inlineParams;
	String queryStatus; //if query is disabled, don't run job
	String lastFileName;
	String exportPath;
	java.sql.Timestamp jobStartDate; //store job start date. relevant for split jobs
	String jobAuditKey = ""; //hold identifier for a job run in the audit table
	String jobOwnerStatus; //if job owner is not active, don't run job
	boolean showParameters; //to enable display of parameters in reports
	Map<Integer, ArtQueryParam> displayParams; //to enable display of parameters in reports
	boolean showGraphData; //to enable display of graph data below graph for pdf output
	private boolean showGraphLegend;
	private boolean showGraphLabels;
	private boolean showGraphDataPoints;
	private String jobGraphOptions; //custom graph options defined for the job
	private String cc;
	private String bcc;
	Map<String, ArtQueryParam> htmlParams;
	private int recipientsQueryId; //to support dynamic recipients
	final String RESULT_SEPARATOR = "\n"; //newline character to use to separate result filename and result message where a message exists
	private int runsToArchive; //number of job runs to archive

	/**
	 * Instantiate a new "empty" Job (to insert/save) A new Job is created. Use
	 * the setXyx methods to set properties, then save() to store the new job on
	 * the ART repository (Connection c).
	 */
	public ArtJob() {
		exportPath = ArtConfig.getExportPath();
	}

	/**
	 * @return the runsToArchive
	 */
	public int getRunsToArchive() {
		return runsToArchive;
	}

	/**
	 * @param runsToArchive the runsToArchive to set
	 */
	public void setRunsToArchive(int runsToArchive) {
		this.runsToArchive = runsToArchive;
	}

	/**
	 * @return the recepientsQueryId
	 */
	public int getRecipientsQueryId() {
		return recipientsQueryId;
	}

	/**
	 * @param recepientsQueryId the recepientsQueryId to set
	 */
	public void setRecipientsQueryId(int recipientsQueryId) {
		this.recipientsQueryId = recipientsQueryId;
	}

	/**
	 * @return the cc
	 */
	public String getCc() {
		return cc;
	}

	/**
	 * @param cc the cc to set
	 */
	public void setCc(String cc) {
		this.cc = cc;
	}

	/**
	 * @return the bcc
	 */
	public String getBcc() {
		return bcc;
	}

	/**
	 * @param bcc the bcc to set
	 */
	public void setBcc(String bcc) {
		this.bcc = bcc;
	}

	/**
	 * Get the custom graph options defined for the job
	 *
	 * @return the custom graph options defined for the job
	 */
	public String getJobGraphOptions() {
		return jobGraphOptions;
	}

	/**
	 * Set the custom graph options defined for the job
	 *
	 * @param jobGraphOptions the custom graph options defined for the job
	 */
	public void setJobGraphOptions(String jobGraphOptions) {
		this.jobGraphOptions = jobGraphOptions;
	}

	/**
	 * Determine if graph legend should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphLegend() {
		return showGraphLegend;
	}

	/**
	 * Determine if graph legend should be shown
	 *
	 * @param showGraphLegend
	 */
	public void setShowGraphLegend(boolean showGraphLegend) {
		this.showGraphLegend = showGraphLegend;
	}

	/**
	 * Determine if graph labels should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphLabels() {
		return showGraphLabels;
	}

	/**
	 * Determine if graph labels should be shown
	 *
	 * @param showGraphLabels
	 */
	public void setShowGraphLabels(boolean showGraphLabels) {
		this.showGraphLabels = showGraphLabels;
	}

	/**
	 * Determine if graph data points should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphDataPoints() {
		return showGraphDataPoints;
	}

	/**
	 * Determine if graph data points should be shown
	 *
	 * @param showGraphDataPoints
	 */
	public void setShowGraphDataPoints(boolean showGraphDataPoints) {
		this.showGraphDataPoints = showGraphDataPoints;
	}

	/**
	 * Determine if graph data should be shown below graph for pdf output
	 *
	 * @param value <code>true</code> is graph data should be shown in output
	 */
	public void setShowGraphData(boolean value) {
		showGraphData = value;
	}

	/**
	 * Determine if graph data should be shown below graph for pdf output
	 *
	 * @return <code>true</code> is graph data should be shown in output
	 */
	public boolean isShowGraphData() {
		return showGraphData;
	}

	/**
	 * Determine is parameters should be shown in output
	 *
	 * @param value <code>true</code> is parameters should be shown in output
	 */
	public void setShowParameters(boolean value) {
		showParameters = value;
	}

	/**
	 * Determine is parameters should be shown in output
	 *
	 * @return <code>true</code> is parameters should be shown in output
	 */
	public boolean isShowParameters() {
		return showParameters;
	}

	/**
	 * Set string that displays the job's parameters
	 *
	 * @param value string that displays the job's parameters
	 */
	public void setParametersDisplayString(String value) {
		parametersDisplayString = value;
	}

	/**
	 *
	 * @return string to display job parameter values
	 */
	public String getParametersDisplayString() {
		return parametersDisplayString;
	}

	/**
	 *
	 * @return last end date for shared job
	 */
	public java.util.Date getSharedLastEndDate() {
		return sharedLastEndDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedLastEndDate(java.util.Date value) {
		sharedLastEndDate = value;
	}

	/**
	 *
	 * @return job last end date
	 */
	public java.util.Date getLastEndDate() {
		return lastEndDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastEndDate(java.util.Date value) {
		lastEndDate = value;
	}

	/**
	 *
	 * @return last start date for shared job
	 */
	public java.util.Date getSharedLastStartDate() {
		return sharedLastStartDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedLastStartDate(java.util.Date value) {
		sharedLastStartDate = value;
	}

	/**
	 *
	 * @return shared file name
	 */
	public String getSharedFileName() {
		return sharedFileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedFileName(String value) {
		sharedFileName = value;
	}

	/**
	 *
	 * @return job last start date
	 */
	public java.util.Date getLastStartDate() {
		return lastStartDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastStartDate(java.util.Date value) {
		lastStartDate = value;
	}

	/**
	 *
	 * @return file name in the jobs table
	 */
	public String getFileName() {
		return fileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setFileName(String value) {
		fileName = value;
	}

	/**
	 *
	 * @return job name
	 */
	public String getJobName() {
		//if job name is empty, use query name as job name
		if (StringUtils.isBlank(jobName)) {
			jobName = queryName;
		}
		return jobName;
	}

	/**
	 *
	 * @param value
	 */
	public void setJobName(String value) {
		jobName = value;
	}

	/**
	 *
	 * @return allow sharing setting
	 */
	public String getAllowSharing() {
		return allowSharing;
	}

	/**
	 *
	 * @param value
	 */
	public void setAllowSharing(String value) {
		allowSharing = value;
	}

	/**
	 *
	 * @return allow splitting setting
	 */
	public String getAllowSplitting() {
		return allowSplitting;
	}

	/**
	 *
	 * @param value
	 */
	public void setAllowSplitting(String value) {
		allowSplitting = value;
	}

	/**
	 *
	 * @return whether rules should be applied to query
	 */
	public String getQueryRulesFlag() {
		return queryRulesFlag;
	}

	/**
	 *
	 * @param value
	 */
	public void setQueryRulesFlag(String value) {
		queryRulesFlag = value;
	}

	/**
	 *
	 * @return job last file name
	 */
	public String getLastFileName() {
		return lastFileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastFileName(String value) {
		lastFileName = value;
	}

	/**
	 *
	 * @return query status
	 */
	public String getQueryStatus() {
		return queryStatus;
	}

	/**
	 *
	 * @param value
	 */
	public void setQueryStatus(String value) {
		queryStatus = value;
	}

	/**
	 *
	 * @return setting indicating whether job has been migrated to quartz
	 */
	public String getMigratedToQuartz() {
		return migratedToQuartz;
	}

	/**
	 *
	 * @param value
	 */
	public void setMigratedToQuartz(String value) {
		migratedToQuartz = value;
	}

	/**
	 *
	 * @return job start date
	 */
	public java.util.Date getStartDate() {
		return startDate;
	}

	/**
	 *
	 * @return job end date
	 */
	public java.util.Date getEndDate() {
		return endDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setStartDate(java.util.Date value) {
		startDate = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setEndDate(java.util.Date value) {
		endDate = value;
	}

	/**
	 * Specifically for use with editjob.jsp. To work around problems with
	 * implicit date-string conversions. Not saved to the database
	 *
	 * @return start date string
	 */
	public String getStartDateString() {
		if (startDateString != null && startDateString.equals("") && startDate != null) {
			//get start date string from the date variable
			SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
			startDateString = dateFormatter.format(startDate);
		}
		return startDateString;
	}

	/**
	 *
	 * @return job end date string
	 */
	public String getEndDateString() {
		if (endDateString != null && endDateString.equals("") && endDate != null) {
			//get end date string from the date variable
			SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
			endDateString = dateFormatter.format(endDate);
		}
		return endDateString;
	}

	/**
	 *
	 * @param value
	 */
	public void setStartDateString(String value) {
		startDateString = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setEndDateString(String value) {
		endDateString = value;
	}
	//

	/**
	 * generate uuid that can be used as a primary key
	 *
	 * @return
	 */
	private String generateKey() {
		return UUID.randomUUID().toString();
	}

	/**
	 *
	 * @param date
	 */
	public void setNextRunDate(java.util.Date date) {
		nextRunDate = date;
	}

	/**
	 *
	 * @return next run date
	 */
	public java.util.Date getNextRunDate() {
		return nextRunDate;
	}

	/**
	 *
	 * @param jId
	 */
	public void setJobId(int jId) {
		load(jId); //load so that in editJob.jsp, job details are displayed        
	}

	/**
	 *
	 * @param jId
	 */
	public void setJobIdOnly(int jId) {
		jobId = jId; //set jobid only, without loading all job details
	}

	/**
	 *
	 * @param i
	 */
	public void setQueryId(int i) {
		queryId = i;
	}

	/**
	 *
	 * @param s
	 */
	public void setUsername(String s) {
		username = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setQueryName(String s) {
		queryName = s;
	}

	/**
	 *
	 * @param i
	 */
	public void setQueryType(int i) {
		queryType = i;
	}

	/**
	 *
	 * @return query type
	 */
	public int getQueryType() {
		return queryType;
	}

	/**
	 *
	 * @param s
	 */
	public void setOutputFormat(String s) {
		outputFormat = s;
	}

	/**
	 *
	 * @param i
	 */
	public void setJobType(int i) {
		jobType = i;
	}

	/**
	 *
	 * @param s
	 */
	public void setTos(String s) {
		if (StringUtils.length(s) > 254) {
			s = s.substring(0, 254);
		}
		tos = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setFrom(String s) {
		from = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setSubject(String s) {
		subject = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setMessage(String s) {
		if (StringUtils.length(s) > 4000) {
			s = s.substring(0, 4000);
		}
		message = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setEnableAudit(String s) {
		enableAudit = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setActiveStatus(String s) {
		activeStatus = s;
	}

	/**
	 *
	 * @param value
	 */
	public void setMinute(String value) {
		minute = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setHour(String value) {
		hour = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setDay(String value) {
		day = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setWeekday(String value) {
		weekday = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setMonth(String value) {
		month = value;
	}

	/**
	 *
	 * @return job id
	 */
	public int getJobId() {
		return jobId;
	}

	/**
	 *
	 * @return query id
	 */
	public int getQueryId() {
		return queryId;
	}

	/**
	 *
	 * @return job owner
	 */
	public String getUsername() {
		return username;
	}

	/**
	 *
	 * @return query name
	 */
	public String getQueryName() {
		return queryName;
	}

	/**
	 *
	 * @return output format
	 */
	public String getOutputFormat() {
		return outputFormat;
	}

	/**
	 *
	 * @return job type
	 */
	public int getJobType() {
		return jobType;
	}

	/**
	 *
	 * @return email addresses of recipients
	 */
	public String getTos() {
		return tos;
	}

	/**
	 *
	 * @return from email address
	 */
	public String getFrom() {
		return from;
	}

	/**
	 *
	 * @return subject of email message
	 */
	public String getSubject() {
		return subject;
	}

	/**
	 *
	 * @return email body contents
	 */
	public String getMessage() {
		return message;
	}

	/**
	 *
	 * @return enable audit setting
	 */
	public String getEnableAudit() {
		return enableAudit;
	}

	/**
	 *
	 * @return active status
	 */
	public String getActiveStatus() {
		return activeStatus;
	}

	/**
	 *
	 * @return minute of the day that the job should run
	 */
	public String getMinute() {
		return minute;
	}

	/**
	 *
	 * @return hour of the day that job should run
	 */
	public String getHour() {
		return hour;
	}

	/**
	 *
	 * @return day of the month that job should run
	 */
	public String getDay() {
		return day;
	}

	/**
	 *
	 * @return weekday that job should run
	 */
	public String getWeekday() {
		return weekday;
	}

	/**
	 *
	 * @return month of the year that job should run
	 */
	public String getMonth() {
		return month;
	}

	/**
	 *
	 * @return cached table name
	 */
	public String getCachedTableName() {
		return cachedTableName;
	}

	/**
	 *
	 * @param s
	 */
	public void setCachedTableName(String s) {
		if (s == null) {
			s = "CACHED_TABLE";
		}
		cachedTableName = s.trim();
	}

	/**
	 * execute job
	 *
	 * @param context
	 * @throws JobExecutionException
	 */
	@Override
	public void execute(JobExecutionContext context) throws JobExecutionException {
		JobDataMap dataMap = null;

		int tempJobId = 0;
		if (context != null) {
			dataMap = context.getMergedJobDataMap();
			tempJobId = dataMap.getInt("jobid");

			logger.debug("Attempting to load Job Id {}", tempJobId);

			load(tempJobId);
		}

		if (jobId == -1) {
			//job not found. exit
			logger.debug("Job Id {} not found", tempJobId);
			return;
		}

		logger.debug("Job Id {} running...", jobId);

		Connection conn = null;

		try {
			conn = ArtConfig.getConnection();

			//get next run date	for the job for updating the jobs table. only update if it's a scheduled run and not an interactive, temporary job
			String tempJob = dataMap.getString("tempjob");
			if (tempJob == null) {
				//not a temp job. set next run date
				nextRunDate = context.getTrigger().getFireTimeAfter(new java.util.Date());
			}

			// set overall job start time in the jobs table
			beforeExecution(conn);

			//don't run job if query or job or job owner is disabled
			if (StringUtils.equals("D", jobOwnerStatus)) {
				//job owner disabled. don't run job. just update jobs table with current status
				fileName = "-Job Owner Disabled";
			} else if (StringUtils.equals("D", queryStatus)) {
				//query disabled. don't run job. just update jobs table with current status
				fileName = "-Query Disabled";
			} else if (StringUtils.equals("N", activeStatus)) {
				//job disabled. don't run job. just update jobs table with current status
				fileName = "-Job Disabled";
			} else {
				//run job. handle dynamic recipients
				if (recipientsQueryId > 0) {
					//job has dynamic recipients
					runDynamicRecipientsJob(conn);
				} else {
					//job doesn't have dynamic recipients
					runNormalJob(conn);
				}
			}

			//set job table's final end time and file name
			afterCompletion(conn);

		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}
	}

	private void runDynamicRecipientsJob(Connection conn) {

		ReportRunner recipientsQuery = null; //recipients query
		try {
			//get recipient data
			recipientsQuery = prepareQuery(username, recipientsQueryId, false);

			recipientsQuery.setAdminSession(true); //don't check security
			recipientsQuery.execute();

			ResultSet rs = recipientsQuery.getResultSet();
			ResultSetMetaData rsmd = rs.getMetaData();
			int columnCount = rsmd.getColumnCount();

			if (columnCount == 1) {
				//only email column. add dynamic recipient emails to Tos and run like normal job
				ArrayList<String> emailsList = new ArrayList<String>();
				while (rs.next()) {
					String email = rs.getString(1); //first column has email addresses
					if (StringUtils.length(email) > 4) {
						emailsList.add(email);
					}
				}
				rs.close();

				if (!emailsList.isEmpty()) {
					String emails = StringUtils.join(emailsList, ";");
					runNormalJob(conn, emails);
				}
			} else if (columnCount > 1) {
				//personalization fields present
				//Get the column names. column indices start from 1
				ArrayList<String> columnList = new ArrayList<String>();
				for (int i = 1; i < columnCount + 1; i++) {
					String columnName = rsmd.getColumnLabel(i); //use alias if available

					//store column names in lowercase to ensure special columns are found by list.contains()
					//some RDBMSs make all column names uppercase					
					columnList.add(columnName.toLowerCase(Locale.ENGLISH));
				}

				if (columnList.contains(ArtUtils.RECIPIENT_COLUMN) && columnList.contains(ArtUtils.RECIPIENT_ID)) {
					//separate emails, different email message, different report data
					while (rs.next()) {
						String email = rs.getString(1); //first column has email addresses
						Map<String, String> recipientColumns = new HashMap<String, String>();
						String columnName;
						String columnValue;
						for (int i = 1; i <= columnCount; i++) { //column numbering starts from 1 not 0
							columnName = rsmd.getColumnLabel(i); //use column alias if available

							if (rs.getString(columnName) == null) {
								columnValue = "";
							} else {
								columnValue = rs.getString(columnName);
							}
							recipientColumns.put(columnName.toLowerCase(), columnValue); //use lowercase so that special columns are found
						}

						if (StringUtils.length(email) > 4) {
							Map<String, Map<String, String>> recipient = new HashMap<String, Map<String, String>>();
							recipient.put(email, recipientColumns);

							//run job for this recipient
							runJob(conn, true, username, tos, recipient, true);
						}
					}
					rs.close();

					//run normal job in case tos, cc etc configured
					if (StringUtils.length(tos) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4) {
						runNormalJob(conn);
					}
				} else {
					//separate emails, different email message, same report data
					Map<String, Map<String, String>> recipients = new HashMap<String, Map<String, String>>();
					while (rs.next()) {
						String email = rs.getString(1); //first column has email addresses
						Map<String, String> recipientColumns = new HashMap<String, String>();
						String columnName;
						String columnValue;
						for (int i = 1; i <= columnCount; i++) { //column numbering starts from 1 not 0
							columnName = rsmd.getColumnLabel(i); //use column alias if available

							if (rs.getString(columnName) == null) {
								columnValue = "";
							} else {
								columnValue = rs.getString(columnName);
							}
							recipientColumns.put(columnName, columnValue);
						}

						if (StringUtils.length(email) > 4) {
							recipients.put(email, recipientColumns);
						}
					}
					rs.close();

					//run job for all recipients
					runJob(conn, true, username, tos, recipients);
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			if (recipientsQuery != null) {
				recipientsQuery.close();
			}
		}
	}

	private void runNormalJob(Connection conn) {
		runNormalJob(conn, null);
	}

	private void runNormalJob(Connection conn, String dynamicRecipients) {
		//run job. if job isn't shared, generate single output
		//if job is shared and doesn't use rules, generate single output to be used by all users
		//if job is shared and uses rules, generate multiple, individualized output for each shared user

		try {

			int userCount = 0; //number of shared users
			String ownerFileName = null; //for shared jobs, ensure the jobs table has the job owner's file

			boolean splitJob = false; //flag to determine if job will generate one file or multiple individualized files. to know which tables to update

			if (StringUtils.equals(allowSharing, "Y")) {
				if (StringUtils.equals(queryRulesFlag, "Y") && StringUtils.equals(allowSplitting, "Y")) {
					splitJob = true;
				}

				if (splitJob) {
					//generate individualized output for all shared users

					//update art_user_jobs table with users who have access through group membership. so that users newly added to a group can get their own output
					addSharedJobUsers(conn, jobId);

					//get users to generate output for
					String usersSQL = "SELECT auj.USERNAME, au.EMAIL "
							+ " FROM ART_USER_JOBS auj, ART_USERS au "
							+ " WHERE auj.USERNAME = au.USERNAME "
							+ " AND auj.JOB_ID = ? AND au.ACTIVE_STATUS='A'";

					PreparedStatement ps = conn.prepareStatement(usersSQL);
					ps.setInt(1, jobId);

					ResultSet rs = ps.executeQuery();
					while (rs.next()) {
						userCount += 1;
						String user = rs.getString("USERNAME");
						runJob(conn, splitJob, user, rs.getString("EMAIL"));
						//ensure that the job owner's output version is saved in the jobs table
						if (username.equals(user)) {
							ownerFileName = fileName;
						}
					}
					rs.close();
					ps.close();

					if (userCount == 0) {
						//no shared users defined yet. generate one file for the job owner
						String emails = tos;
						if (dynamicRecipients != null) {
							emails = emails + ";" + dynamicRecipients;
						}
						runJob(conn, splitJob, username, emails);
					}
				} else {
					//generate one single output to be used by all users
					String emails = getSharedJobEmails();
					if (dynamicRecipients != null) {
						emails = emails + ";" + dynamicRecipients;
					}
					runJob(conn, splitJob, username, emails);
				}
			} else {
				//job isn't shared. generate one file for the job owner
				String emails = tos;
				if (dynamicRecipients != null) {
					emails = emails + ";" + dynamicRecipients;
				}
				runJob(conn, splitJob, username, emails);
			}

			//ensure jobs table always has job owner's file, or a note if no output was produced for the job owner
			if (ownerFileName != null) {
				fileName = ownerFileName;
			} else if (splitJob && userCount > 0) {
				//job is shared with other users but the owner doesn't have a copy. save note in the jobs table
				fileName = "-Job Shared";
			}
		} catch (Exception e) {
			logger.error("Error", e);
		}
	}

	private void runJob(Connection conn, boolean splitJob, String user, String userEmail) {
		runJob(conn, splitJob, user, userEmail, null, false);
	}

	private void runJob(Connection conn, boolean splitJob, String user, String userEmail, Map<String, Map<String, String>> recipientDetails) {
		runJob(conn, splitJob, user, userEmail, recipientDetails, false);
	}

	//run job
	private void runJob(Connection conn, boolean splitJob, String user, String userEmail,
			Map<String, Map<String, String>> recipientDetails, boolean recipientFilterPresent) {
		//set job start date. relevant for split jobs
		jobStartDate = new Timestamp(new java.util.Date().getTime());

		ReportRunner pq = null;

		fileName = "-No File"; //reset file name

		//create job audit record if auditing is enabled
		createAuditRecord(conn, user);

		try {
			pq = prepareQuery(user);

			//for split jobs, don't check security. shared users have been allowed access to the output
			if (splitJob) {
				pq.setAdminSession(true);
			}

			if (recipientFilterPresent) {
				//enable report data to be filtered/different for each recipient
				pq.setRecipientFilterPresent(recipientFilterPresent);
				for (Map.Entry<String, Map<String, String>> entry : recipientDetails.entrySet()) {
					//map should only have one value if filter present
					Map<String, String> recipientColumns = entry.getValue();
					pq.setRecipientColumn(recipientColumns.get(ArtUtils.RECIPIENT_COLUMN));
					pq.setRecipientId(recipientColumns.get(ArtUtils.RECIPIENT_ID));
					pq.setRecipientIdType(recipientColumns.get(ArtUtils.RECIPIENT_ID_TYPE));
				}
			}

			//need scrollable resultset for graphs for show data option
			//also jxls always requires scrollable resultset
			//much worse performance compared to forward only?
			int resultSetType=ResultSet.TYPE_SCROLL_INSENSITIVE;

			/*
			 * BEGIN EXECUTE QUERY
			 */
			pq.execute(resultSetType);


			/*
			 * END EXECUTE QUERY
			 */
			/*
			 * Job Types: 1 = Alert 2 = Mails as attachment 3 = Publish 4 = Just
			 * Run 5 = Mail with output within the email as html 6 = Mails as
			 * attachment only if query returns one or more rows 7 = Mail with
			 * output within the email as html only if query returns one or more
			 * rows 8 = Publish only if query returns one or more rows 9 = Cache
			 * the result set in the cache database (append) 10 = Cache the
			 * result set in the cache database (drop/insert)
			 */
			//trim address fields. to aid in checking if emails are configured
			userEmail = StringUtils.trim(userEmail);
			tos = StringUtils.trim(tos);
			cc = StringUtils.trim(cc);
			bcc = StringUtils.trim(bcc);

			//determine if emailing is required and emails are configured
			boolean generateEmail = false;
			if (jobType == 3 || jobType == 8) {
				//for split published jobs, tos should have a value to enable confirmation email for individual users
				if (!StringUtils.equals(tos, userEmail) && (StringUtils.length(tos) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4) && StringUtils.length(userEmail) > 4) {
					generateEmail = true;
				} else if (StringUtils.equals(tos, userEmail) && (StringUtils.length(tos) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4)) {
					generateEmail = true;
				}
			} else {
				//for non-publish jobs, if an email address is available, generate email
				if (StringUtils.length(userEmail) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4) {
					generateEmail = true;
				}
			}

			//set email fields
			String[] tosEmail = null;
			String[] ccs = null;
			String[] bccs = null;
			if (generateEmail) {
				tosEmail = StringUtils.split(userEmail, ";");
				ccs = StringUtils.split(cc, ";");
				bccs = StringUtils.split(bcc, ";");

				logger.debug("Job Id {}. to: {}", jobId, userEmail);
				logger.debug("Job Id {}. cc: {}", jobId, cc);
				logger.debug("Job Id {}. bcc: {}", jobId, bcc);
			}

			if (jobType == 1) {
				/*
				 * ALERT if the resultset is not null and the first column is a
				 * positive integer => send the alert email
				 */

				//only run alert query if we have some emails configured
				if (generateEmail || recipientDetails != null) {
					fileName = "-No Alert";

					ResultSet rs = pq.getResultSet();
					if (rs.next()) {
						int value = rs.getInt(1);
						if (value > 0) {
							logger.debug("Job Id {} - Raising Alert. Value is {}", jobId, value);

							// compatibility with Art pre 1.8 where subject was not editable
							if (subject == null) {
								subject = "ART Alert: " + jobName + " (Job " + jobId + ")";
							}

							//send customized emails to dynamic recipients
							if (recipientDetails != null) {
								Mailer mailer = getMailer();

								for (Map.Entry<String, Map<String, String>> entry : recipientDetails.entrySet()) {
									String email = entry.getKey();
									Map<String, String> recipientColumns = entry.getValue();

									//customize message by replacing field labels with values for this recipient
									String customMessage = message; //message for a particular recipient. may include personalization e.g. Dear Jane
									if (customMessage == null) {
										customMessage = "";
									}

									if (StringUtils.isNotBlank(customMessage)) {
										for (Map.Entry<String, String> entry2 : recipientColumns.entrySet()) {
											String columnName = entry2.getKey();
											String columnValue = entry2.getValue();

											String searchString = Pattern.quote("#" + columnName + "#"); //quote in case it contains special regex characters
											String replaceString = Matcher.quoteReplacement(columnValue); //quote in case it contains special regex characters
											customMessage = customMessage.replaceAll("(?iu)" + searchString, replaceString); //(?iu) makes replace case insensitive across unicode characters
										}
									}

									prepareAlertJob(mailer, customMessage);

									mailer.setTo(email);

									//send email for this recipient
									try {
										mailer.send();
										fileName = "-Alert Sent";
									} catch (MessagingException ex) {
										logger.debug("Error", ex);
										fileName = "-Error when sending alert <p>" + ex.toString() + "</p>";

									}
								}

								if (recipientFilterPresent) {
									//don't run normal email job after filtered email sent
									generateEmail = false;
								}
							}

							//send email to normal recipients
							if (generateEmail) {
								Mailer mailer = getMailer();

								prepareAlertJob(mailer, message);

								//set recipients						
								mailer.setTo(tosEmail);
								mailer.setCc(ccs);
								mailer.setBcc(bccs);

								try {
									mailer.send();
									fileName = "-Alert Sent";
								} catch (MessagingException ex) {
									logger.debug("Error", ex);
									fileName = "-Error when sending alert <p>" + ex.toString() + "</p>";

								}

							} else {
								logger.debug("Job Id {} - No Alert. Value is {}", jobId, value);
							}
						} else {
							logger.debug("Job Id {} - Empty resultset for alert", jobId);
						}
					}
				} else {
					//no emails configured
					fileName = "-No emails configured";
				}
			} else if (jobType == 2 || jobType == 3 || jobType == 5 || jobType == 6 || jobType == 7 || jobType == 8) {
				/*
				 * MAILwithAttachment or PUBLISH or MAILinLine
				 */
				ResultSet rs = null;
				ResultSetMetaData rsmd = null;
				if (queryType != 115 && queryType != 117) {
					rs = pq.getResultSet();
					rsmd = rs.getMetaData();
				}

				logger.debug("Job Id {} - Mail or Publish. Type: {}", jobId, jobType);

				//determine if the query returns records. to know if to generate output for conditional jobs
				boolean generateOutput = true;

				if (jobType == 6 || jobType == 7 || jobType == 8) {
					//conditional job. check if resultset has records. no "recordcount" method so we have to execute query again
					ReportRunner pqCount = prepareQuery(user);
					pqCount.setAdminSession(true);
					pqCount.execute();
					ResultSet rsCount = pqCount.getResultSet();
					if (!rsCount.next()) {
						//no records
						generateOutput = false;
						fileName = "-No Records";
					}
					rsCount.close();
					pqCount.close();
				}

				//for emailing jobs, only run query if some emails are configured
				if (jobType == 2 || jobType == 5 || jobType == 6 || jobType == 7) {
					//email attachment, email inline, conditional email attachment, conditional email inline
					if (!generateEmail && recipientDetails == null) {
						generateOutput = false;
						fileName = "-No emails configured";
					}
				}

				if (generateOutput) {
					String sep = java.io.File.separator;
					String jobsPath = exportPath + "jobs" + sep;
					String jobFileUsername = "JobId" + jobId;

					if (queryType < 0) {
						//save charts to file
						ExportGraph eg = new ExportGraph();
						eg.setFileUserName(jobFileUsername);
						eg.setQueryName(queryName);
						eg.setExportPath(jobsPath);
						eg.setOutputFormat(outputFormat); // png or pdf
						eg.setXAxisLabel(xAxisLabel);
						eg.setYAxisLabel(yAxisLabel);
						eg.setTitle(queryShortDescription);
						eg.setShowData(showGraphData); //enable display of graph data below graph for pdf graph output
						eg.setDisplayParameters(displayParams); //enable display of graph parameters above graph for pdf graph output
						eg.setShowDataPoints(showGraphDataPoints);
						eg.setShowLegend(showGraphLegend);
						eg.setShowLabels(showGraphLabels);
						eg.setQueryId(queryId);
						eg.setGraphOptions(jobGraphOptions);

						eg.createFile(rs, queryType);
						fileName = eg.getFileName();
					} else if (queryType == 115 || queryType == 116) {
						//jasper report
						JasperReportsOutput jasper = new JasperReportsOutput();
//						jasper.setQueryName(queryName);
//						jasper.setFileUserName(jobFileUsername);
						jasper.setExportPath(jobsPath);
						jasper.setReportFormat(outputFormat);

						if (queryType == 115) {
							//report will use query in the report template
//							jasper.createFile(null, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						} else {
							//report will use data from art query
//							jasper.createFile(rs, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						}
						fileName = jasper.getFileName();
					} else if (queryType == 117 || queryType == 118) {
						//jxls spreadsheet
						JxlsOutput jxls = new JxlsOutput();
						jxls.setQueryName(queryName);
						jxls.setFileUserName(jobFileUsername);
						jxls.setExportPath(jobsPath);

						if (queryType == 117) {
							//report will use query in the jxls template
							jxls.createFile(null, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						} else {
							//report will use data from art query
							jxls.createFile(rs, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						}
						fileName = jxls.getFileName();
					} else {
						ReportOutputInterface o;

						String classToLoad = "art.output." + outputFormat + "Output";
						ClassLoader cl = this.getClass().getClassLoader();
						Object obj = cl.loadClass(classToLoad).newInstance();

						o = (ReportOutputInterface) obj;

						o.setMaxRows(ArtConfig.getMaxRows(outputFormat));

						//printwriter not needed for all output types. Avoid creating extra html file when output is not html, xml or rss
						FileOutputStream fos = null;
						PrintWriter out = null;
						boolean printWriterUsed = false;

						if (outputFormat.indexOf("html") >= 0 || outputFormat.indexOf("xml") >= 0 || outputFormat.indexOf("rss") >= 0) {
							if (outputFormat.indexOf("html") >= 0) {
								SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy_MM_dd-HH_mm_ss");
								String datePart = dateFormatter.format(new java.util.Date());

								fileName = jobFileUsername + "-" + queryName + "-" + datePart + ArtUtils.getRandomFileNameString() + ".html";
								fileName = ArtUtils.cleanFileName(fileName);
								fileName = jobsPath + fileName;

							} else {
								//xml or rss
								fileName = jobFileUsername + ".html";
								fileName = ArtUtils.cleanFileName(fileName);
								fileName = jobsPath + fileName;
							}
							fos = new FileOutputStream(fileName);
							out = new PrintWriter(new OutputStreamWriter(fos, "UTF-8")); // make sure we make a utf-8 encoded text
							o.setWriter(out);
							printWriterUsed = true;
						}

						o.setQueryName(queryName);
						o.setFileUserName(jobFileUsername);
						o.setExportPath(jobsPath);
						o.setDisplayParameters(displayParams);

						ResourceBundle messages = ResourceBundle.getBundle("i18n.ArtMessages");
						if (queryType == 101 || queryType == 102) {
//							ReportOutputHandler.flushXOutput(messages, o, rs, rsmd);
						} else {
//							ReportOutputHandler.flushOutput(messages, o, rs, rsmd);
						}

						/*
						 * Now the resultset has been flushed in the o ArtOutput
						 * object and therefore it has been: 1. streamed in the
						 * out PrintWriter (file) (or) 2. written in another
						 * file if the o object did it (for example xls view
						 * mode) Thus now we need to discover where the output
						 * is (in the out object or in another file)
						 */
						if (o.getFileName() != null) {
							fileName = o.getFileName();
						}

						// the file is on the PrintWriter (for html)
						if (printWriterUsed) {
							out.close();
							fos.close();
						}
					}

					// fileName now stores the file to email or publish...                    
					logger.debug("Job Id {}. File is: {}", jobId, fileName);

					if (generateEmail || recipientDetails != null) {
						//some kind of emailing required

						// compatibility with Art pre 1.8 where subject was not editable
						if (subject == null) {
							subject = "ART Scheduler: " + jobName + " (Job " + jobId + ")";
						}

						//send customized emails to dynamic recipients
						if (recipientDetails != null) {
							Mailer mailer = getMailer();

							String email = "";

							for (Map.Entry<String, Map<String, String>> entry : recipientDetails.entrySet()) {
								email = entry.getKey();
								Map<String, String> recipientColumns = entry.getValue();

								//customize message by replacing field labels with values for this recipient
								String customMessage = message; //message for a particular recipient. may include personalization e.g. Dear Jane
								if (customMessage == null) {
									customMessage = "";
								}

								if (StringUtils.isNotBlank(customMessage)) {
									for (Map.Entry<String, String> entry2 : recipientColumns.entrySet()) {
										String columnName = entry2.getKey();
										String columnValue = entry2.getValue();

										String searchString = Pattern.quote("#" + columnName + "#"); //quote in case it contains special regex characters
										String replaceString = Matcher.quoteReplacement(columnValue); //quote in case it contains special regex characters
										customMessage = customMessage.replaceAll("(?iu)" + searchString, replaceString); //(?iu) makes replace case insensitive across unicode characters
									}
								}

								prepareEmailJob(mailer, customMessage);

								mailer.setTo(email);

								//send email for this recipient
								try {
									mailer.send();
									fileName = "-File has been emailed";
								} catch (MessagingException ex) {
									logger.debug("Error", ex);
									fileName = "-Error when sending some emails."
											+ " <p>" + ex.toString() + "</p>";

									String msg = "Error when sending some emails."
											+ " \n" + ex.toString()
											+ " \n To: " + email;
									logger.warn(msg);

								}
							}

							if (recipientFilterPresent) {
								//don't run normal email job after filtered email sent
								generateEmail = false;
							}

							//set filename to status of last recipient email sent
							File f = new File(fileName);
							boolean deleted = f.delete();
							if (!deleted) {
								logger.warn("Email attachment file not deleted: {}", fileName);
							}
						}

						//send email to normal recipients
						if (generateEmail) {
							Mailer mailer = getMailer();

							prepareEmailJob(mailer, message);

							//set recipients						
							mailer.setTo(tosEmail);
							mailer.setCc(ccs);
							mailer.setBcc(bccs);

							//check if mail was successfully sent
							try {
								mailer.send();
								fileName = "-File has been emailed";
							} catch (MessagingException ex) {
								logger.debug("Error", ex);
								fileName = "-Error when sending some emails."
										+ " <p>" + ex.toString() + "</p>";

								String msg = "Error when sending some emails."
										+ " \n" + ex.toString()
										+ " \n Complete address list:\n To: " + userEmail + "\n Cc: " + cc + "\n Bcc: " + bcc;
								logger.warn(msg);

							}
							if (jobType == 2 || jobType == 5 || jobType == 6 || jobType == 7) {
								// delete the file since it has
								// been sent via email (for publish jobs it is deleted by the scheduler)
								File f = new File(fileName);
								f.delete();
							} else {
//								//publish job reminder email. separate file link and message with a newline character (\n)
//								if (mailSent) {
//									fileName = fileName + RESULT_SEPARATOR + "<p>Reminder email sent</p>";
//								} else {
//									fileName = fileName + RESULT_SEPARATOR + "<p>Error when sending reminder email <br><br>" + mailer.getSendError() + "</p>";
//								}
							}
						}
					}
				}

			} else if (jobType == 9 || jobType == 10) {
				// Cache the result in the cache database
				int targetDatabaseId = Integer.parseInt(outputFormat);

				Connection cacheDatabaseConnection = DbConnections.getConnection(targetDatabaseId);
				ResultSet rs = pq.getResultSet();
				CachedResult cr = new CachedResult();
				cr.setTargetConnection(cacheDatabaseConnection);
				cr.setResultSet(rs);
				if (cachedTableName == null || cachedTableName.length() == 0) {
					cachedTableName = queryName + "_J" + jobId;
				}
				cr.setCachedTableName(cachedTableName);
				cr.setCacheMode(jobType - 8); // 1 = append 2 = drop/insert (3 = update (not implemented))
				cr.cacheIt();
				cacheDatabaseConnection.close();
				fileName = "- Table Name (rows inserted):  <code>" + cr.getCachedTableName() + "</code> (" + cr.getRowsCount() + ")"
						+ "<br />Columns Names:<br /><code>" + cr.getCachedTableColumnsName() + "</code>";

			} else { // jobType 4:just run it.
				// This is used Used to start batch jobs at db level via calls to stored procs
				// or just to run update statements.
			}

			logger.debug("Job Id {} ...finished", jobId);
		} catch (Exception e) {
			logger.error("Error. Job id={}, User={}", new Object[]{jobId, user, e});
			fileName = "-<b>Error:</b> " + e;
		} finally {
			if (pq != null) {
				pq.close();
			}
			// set audit timestamp and update archives
			afterExecution(conn, splitJob, user);
		}
	}

	/**
	 * Prepare mailer object for sending alert job. Used for normal jobs, and
	 * dynamic recipient jobs
	 *
	 * @param mailer
	 * @param msg
	 */
	private void prepareAlertJob(Mailer mailer, String msg) {
		mailer.setSubject(subject);
		mailer.setFrom(from);
		mailer.setMessage("<html>" + msg + "<hr><small>This is an automatically generated message (ART, Job ID " + jobId + ")</small></html>");
	}

	/**
	 * Prepare mailer object for sending email job. Used for normal jobs, and
	 * dynamic recipient jobs
	 *
	 * @param mailer
	 */
	private void prepareEmailJob(Mailer mailer, String msg) throws FileNotFoundException, IOException {

		mailer.setSubject(subject);
		mailer.setFrom(from);

		if (StringUtils.isBlank(msg)) {
			msg = "&nbsp;"; //if message is blank, ensure there's a space before the hr
		}

		if (jobType == 2 || jobType == 6) {
			// e-mail output as attachment
			List<File> l = new ArrayList<File>();
			l.add(new File(fileName));
			mailer.setAttachments(l);
		} else if (jobType == 5 || jobType == 7) {
			// inline html within email
			// read the file and include it in the HTML message
			FileInputStream fis = new FileInputStream(fileName);
			try {
				byte fileBytes[] = new byte[fis.available()];
				int result = fis.read(fileBytes);
				if (result == -1) {
					logger.warn("EOF reached for inline email file: {}", fileName);
				}
				// convert the file to a string and get only the html table
				String htmlTable = new String(fileBytes, "UTF-8");
				//htmlTable = htmlTable.substring(htmlTable.indexOf("<html>") + 6, htmlTable.indexOf("</html>"));
				htmlTable = htmlTable.substring(htmlTable.indexOf("<body>") + 6, htmlTable.indexOf("</body>")); //html plain output now has head and body sections
				msg = msg + "<hr>" + htmlTable;
			} finally {
				fis.close();
			}
		}

		String autoMessage = "<hr><small>This is an automatically generated message (ART, Job ID " + jobId + ")</small>";
		mailer.setMessage("<html>" + msg + autoMessage + "</html>");
	}

	/**
	 * Update art_user_jobs table with users who have access through group
	 * membership.
	 *
	 * @param conn
	 * @param jId
	 */
	public void addSharedJobUsers(Connection conn, int jId) {
		String sql;
		PreparedStatement ps = null;
		ResultSet rs;
		PreparedStatement psInsert = null;

		try {
			//get users who should have access to the job through group membership but don't already have it
			sql = "SELECT AU.USERNAME, AUGA.USER_GROUP_ID "
					+ " FROM ART_USERS AU, ART_USER_GROUP_ASSIGNMENT AUGA, ART_USER_GROUP_JOBS AUGJ "
					+ " WHERE AU.USERNAME = AUGA.USERNAME AND AUGA.USER_GROUP_ID = AUGJ.USER_GROUP_ID "
					+ " AND AUGJ.JOB_ID = ? "
					+ " AND NOT EXISTS "
					+ " (SELECT * FROM ART_USER_JOBS auj "
					+ " WHERE auj.USERNAME = AU.USERNAME AND auj.JOB_ID = ?)";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jId);
			ps.setInt(2, jId);
			rs = ps.executeQuery();

			sql = "INSERT INTO ART_USER_JOBS (JOB_ID, USERNAME, USER_GROUP_ID) VALUES (?,?,?)";

			psInsert = conn.prepareStatement(sql);
			while (rs.next()) {
				//insert records into the art_user_jobs table so that the users can have access to the job
				try {
					psInsert.setInt(1, jId);
					psInsert.setString(2, rs.getString("USERNAME"));
					psInsert.setString(3, rs.getString("USER_GROUP_ID"));
					psInsert.executeUpdate();
				} catch (Exception e) {
					logger.error("Error. Job id {}", jobId, e);
				}
			}
			rs.close();

		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (psInsert != null) {
					psInsert.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Remove records in art_user_jobs table for users who have been denied
	 * access because their user group has been denied access
	 *
	 * @param conn
	 * @param jId
	 * @param groupId
	 */
	public void removeSharedJobUsers(Connection conn, int jId, int groupId) {
		String sql;
		PreparedStatement ps = null;
		ResultSet rs;
		PreparedStatement psDelete = null;

		try {
			//get users who should be denied access to the job because their group has been denied access
			sql = "SELECT auj.USERNAME "
					+ " FROM ART_USER_JOBS auj, ART_USER_GROUP_JOBS AUGJ "
					+ " WHERE auj.JOB_ID = AUGJ.JOB_ID "
					+ " AND auj.JOB_ID = ? "
					+ " AND EXISTS "
					+ " (SELECT * FROM ART_USER_GROUP_ASSIGNMENT AUGA "
					+ " WHERE AUGA.USER_GROUP_ID=AUGJ.USER_GROUP_ID "
					+ " AND AUGJ.USER_GROUP_ID = ?)";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jId);
			ps.setInt(2, groupId);
			rs = ps.executeQuery();

			//delete records from the art_user_jobs table
			sql = "DELETE FROM ART_USER_JOBS WHERE JOB_ID = ? AND USERNAME = ?";
			psDelete = conn.prepareStatement(sql);
			while (rs.next()) {
				try {
					psDelete.setInt(1, jId);
					psDelete.setString(2, rs.getString("USERNAME"));
					psDelete.executeUpdate();
				} catch (Exception e) {
					logger.error("Error. Job id {}", jId, e);
				}
			}
			rs.close();

		} catch (Exception e) {
			logger.error("Error. Job id={}, Group id={}", new Object[]{jId, groupId, e});
		} finally {
			try {
				if (psDelete != null) {
					psDelete.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Set timestamps in ART_JOBS table before job execution
	 */
	private void beforeExecution(Connection conn) {

		PreparedStatement ps = null;

		try {
			java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

			// Update LAST_START_DATE and next run date on ART_JOBS table
			String sql = "UPDATE ART_JOBS SET LAST_START_DATE = ?, NEXT_RUN_DATE = ? WHERE JOB_ID = ?";
			ps = conn.prepareStatement(sql);
			ps.setTimestamp(1, now);
			if (nextRunDate != null) {
				ps.setTimestamp(2, new java.sql.Timestamp(nextRunDate.getTime()));
			} else {
				ps.setTimestamp(2, null);
			}
			ps.setInt(3, jobId);
			ps.executeUpdate();
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	//create job audit record
	private void createAuditRecord(Connection conn, String user) {

		PreparedStatement ps = null;
		try {
			if (StringUtils.equals(enableAudit, "Y")) {
				//generate unique key for this job run
				jobAuditKey = generateKey();

				String sqlString;
				java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

				//insert job start audit values.
				sqlString = "INSERT INTO ART_JOBS_AUDIT (JOB_ID, JOB_ACTION, JOB_AUDIT_KEY, START_DATE, USERNAME) VALUES (?, 'S', ?, ?, ?)";
				ps = conn.prepareStatement(sqlString);

				ps.setInt(1, jobId);
				ps.setString(2, jobAuditKey);
				ps.setTimestamp(3, now);
				ps.setString(4, user);
				ps.executeUpdate();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	//set final end time and file name of job table
	private void afterCompletion(Connection conn) {

		PreparedStatement ps = null;
		try {
			Timestamp now = new Timestamp(new java.util.Date().getTime());

			String sql;

			//update job details
			sql = "UPDATE ART_JOBS SET LAST_END_DATE = ?, LAST_FILE_NAME = ? WHERE JOB_ID = ?";
			ps = conn.prepareStatement(sql);

			ps.setTimestamp(1, now);
			ps.setString(2, fileName);
			ps.setInt(3, jobId);
			ps.executeUpdate();

		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Update ART_USER_JOBS table. If Audit Flag is set, a new row is added to
	 * ART_JOBS_AUDIT table
	 */
	private void afterExecution(Connection conn, boolean splitJob, String user) {

		PreparedStatement psShared = null;
		PreparedStatement psAudit = null;
		PreparedStatement ps = null;

		try {
			String sql;
			String finalFileName;

			String sep = java.io.File.separator;

			if (fileName.startsWith("-")) {
				finalFileName = fileName;
			} else {
				//file name may have extra text after it, for publish job reminder email status
				if (fileName.indexOf(RESULT_SEPARATOR) > -1) {
					//filename has full path to file and a status message
					finalFileName = StringUtils.substringBefore(fileName, RESULT_SEPARATOR); //get full file path
					finalFileName = finalFileName.substring(finalFileName.lastIndexOf(sep) + 1); // get only filename
					finalFileName = finalFileName + RESULT_SEPARATOR + StringUtils.substringAfter(fileName, RESULT_SEPARATOR); //filename + message
				} else {
					// filename has full path to file. save only filename
					finalFileName = fileName.substring(fileName.lastIndexOf(sep) + 1); // only filename
				}
			}

			if (finalFileName.length() > 4000) {
				finalFileName = finalFileName.substring(0, 4000);
			}

			//update filename field
			fileName = finalFileName;

			if (jobType == 3 || jobType == 8) {
				//for publish jobs, delete previous file and update job archives as necessary
				sql = "SELECT LAST_FILE_NAME, LAST_START_DATE, LAST_END_DATE"
						+ " FROM ART_JOBS"
						+ " WHERE JOB_ID = ?";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ResultSet rs = ps.executeQuery();

				String archiveFileName;
				Timestamp archiveStartDate;
				Timestamp archiveEndDate;

				if (rs.next()) {
					archiveFileName = rs.getString("LAST_FILE_NAME");
					archiveStartDate = rs.getTimestamp("LAST_START_DATE");
					archiveEndDate = rs.getTimestamp("LAST_END_DATE");

					if (runsToArchive > 0 && archiveFileName != null) {
						//update archives
						updateArchives(splitJob, user, archiveFileName, archiveStartDate, archiveEndDate);
					} else {
						//if not archiving, delete previous file
						if (archiveFileName != null && !archiveFileName.startsWith("-")) {
							List<String> details = ArtUtils.getFileDetailsFromResult(archiveFileName);
							archiveFileName = details.get(0);
							String filePath = ArtConfig.getJobsExportPath() + archiveFileName;
							File previousFile = new File(filePath);
							if (previousFile.exists()) {
								previousFile.delete();
							}
						}

						//delete old archives if they exist
						if (runsToArchive == 0) {
							deleteArchives();
						}
					}
				}
				rs.close();
				ps.close();

			}

			Timestamp now = new Timestamp(new java.util.Date().getTime());

			//update job details
			//no need to update jobs table if non-split job. aftercompletion will do the final update to the jobs table
			if (splitJob) {
				sql = "UPDATE ART_USER_JOBS SET LAST_FILE_NAME = ?, LAST_START_DATE = ?, LAST_END_DATE = ? "
						+ " WHERE JOB_ID = ? AND USERNAME = ?";
				psShared = conn.prepareStatement(sql);

				psShared.setString(1, fileName);
				psShared.setTimestamp(2, jobStartDate);
				psShared.setTimestamp(3, now);
				psShared.setInt(4, jobId);
				psShared.setString(5, user);
				psShared.executeUpdate();
				psShared.close();
			}

			//update audit table if required
			if (StringUtils.equals(enableAudit, "Y")) {
				sql = "UPDATE ART_JOBS_AUDIT SET JOB_ACTION = 'E', END_DATE = ? WHERE JOB_AUDIT_KEY = ? AND JOB_ID = ?";
				psAudit = conn.prepareStatement(sql);
				psAudit.setTimestamp(1, now);
				psAudit.setString(2, jobAuditKey);
				psAudit.setInt(3, jobId);
				psAudit.executeUpdate();
				psAudit.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (psShared != null) {
					psShared.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (psAudit != null) {
					psAudit.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Save a job in the database. If the job id is set, updates the existing
	 * job. Otherwise a new job is created.
	 */
	public void save() {
		Connection conn = null;

		try {
			logger.debug("Saving job id {}", jobId);

			conn = ArtConfig.getConnection();

			// Allocate a new job id if job id is not set
			if (jobId == -1) {
				jobId = allocateNewId(conn);
			}

			String sql = "UPDATE ART_JOBS SET"
					+ "   QUERY_ID= ? ,  USERNAME = ? ,  OUTPUT_FORMAT = ? ,  JOB_TYPE = ? "
					+ " , JOB_MINUTE = ? ,  JOB_HOUR = ? ,  JOB_DAY = ? ,  JOB_WEEKDAY= ? ,  JOB_MONTH = ? "
					+ " , MAIL_TOS = ? ,  MAIL_FROM = ? ,  MESSAGE = ? ,  ENABLE_AUDIT = ? ,  ACTIVE_STATUS = ? , SUBJECT = ? "
					+ " , NEXT_RUN_DATE=?, START_DATE=?, END_DATE=?, MIGRATED_TO_QUARTZ=?, ALLOW_SHARING=?, ALLOW_SPLITTING=? "
					+ " , CACHED_TABLE_NAME =?, JOB_NAME=?, MAIL_CC=?, MAIL_BCC=?, RECIPIENTS_QUERY_ID=?, RUNS_TO_ARCHIVE=? "
					+ " WHERE JOB_ID = ?";

			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, queryId);
			ps.setString(2, username);
			ps.setString(3, outputFormat);
			ps.setInt(4, jobType);
			ps.setString(5, minute);
			ps.setString(6, hour);
			ps.setString(7, day);
			ps.setString(8, weekday);
			ps.setString(9, month);
			ps.setString(10, tos);
			ps.setString(11, from);
			ps.setString(12, message);
			ps.setString(13, enableAudit);
			ps.setString(14, activeStatus);
			ps.setString(15, subject);

			if (nextRunDate != null) {
				ps.setTimestamp(16, new java.sql.Timestamp(nextRunDate.getTime()));
			} else {
				ps.setTimestamp(16, null);
			}

			if (startDate != null) {
				ps.setDate(17, new java.sql.Date(startDate.getTime()));
			} else {
				ps.setDate(17, null);
			}
			if (endDate != null) {
				ps.setDate(18, new java.sql.Date(endDate.getTime()));
			} else {
				ps.setDate(18, null);
			}

			ps.setString(19, migratedToQuartz);
			ps.setString(20, allowSharing);
			ps.setString(21, allowSplitting);
			ps.setString(22, cachedTableName);
			ps.setString(23, jobName);
			ps.setString(24, cc);
			ps.setString(25, bcc);
			ps.setInt(26, recipientsQueryId);
			ps.setInt(27, runsToArchive);
			ps.setInt(28, jobId);

			ps.executeUpdate();
			ps.close();

			//save job parameters
			sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
					+ " VALUES (?,?,?,?)";
			ps = conn.prepareStatement(sql);
			boolean batchEmpty = true; //to ensure addBatch is only called if the batch is not empty. hsqldb throws an exception

			//save inline parameters
			if (inlineParams != null) {
				for (Map.Entry<String, String> entry : inlineParams.entrySet()) {
					String name = entry.getKey();
					String value = entry.getValue();

					ps.setInt(1, jobId);
					ps.setString(2, "I");
					ps.setString(3, name);
					ps.setString(4, value);

					ps.addBatch();
					batchEmpty = false;
				}
			}

			//save multi parameters
			if (multiParams != null) {
				for (Map.Entry<String, String[]> entry : multiParams.entrySet()) {
					String name = entry.getKey();
					String values[] = entry.getValue();

					for (int j = 0; j < values.length; j++) {
						ps.setInt(1, jobId);
						ps.setString(2, "M");
						ps.setString(3, name);
						ps.setString(4, values[j]);

						ps.addBatch();
						batchEmpty = false;
					}
				}
			}

			//enable show parameters in job output
			if (showParameters) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showParams");
				ps.setString(4, "true");

				ps.addBatch();
				batchEmpty = false;
			}

			//enable show graph data in pdf output
			if (showGraphData) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphData");
				ps.setString(4, "true");

				ps.addBatch();
				batchEmpty = false;
			}

			//enable custom graph settings
			if (showGraphDataPoints) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphDataPoints");
				ps.setString(4, "true");

				ps.addBatch();
				batchEmpty = false;
			}
			if (showGraphLegend) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphLegend");
				ps.setString(4, "true");

				ps.addBatch();
				batchEmpty = false;
			}
			if (showGraphLabels) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphLabels");
				ps.setString(4, "true");

				ps.addBatch();
				batchEmpty = false;
			}
			if (StringUtils.isNotBlank(jobGraphOptions)) {
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_graphOptions");
				ps.setString(4, jobGraphOptions);

				ps.addBatch();
				batchEmpty = false;
			}

			if (!batchEmpty) {
				ps.executeBatch();
			}
			ps.close();
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Delete this Job. Remove a Job from the database. If the jobs has
	 * parameters, the parameters are removed as well. If the job is a cached
	 * result one, drop the cached table
	 */
	public void delete() {
		Connection conn = null;

		try {
			logger.debug("Attempting to delete Job Id {}", jobId);

			//delete records in quartz tables
			String deleteJobName = "job" + jobId;
			String triggerName = "trigger" + jobId;

			org.quartz.Scheduler scheduler = SchedulerUtils.getScheduler();
			if (scheduler != null) {
				scheduler.deleteJob(jobKey(deleteJobName, ArtUtils.JOB_GROUP)); //delete job records
				scheduler.unscheduleJob(triggerKey(triggerName, ArtUtils.TRIGGER_GROUP)); //delete trigger records
			}

			//delete records from art tables
			conn = ArtConfig.getConnection();

			String SQL = "DELETE FROM ART_JOBS WHERE JOB_ID = ? ";
			PreparedStatement ps = conn.prepareStatement(SQL);
			ps.setInt(1, jobId);

			if (ps.executeUpdate() == 1) { // job exists                
				logger.debug("Job Deleted: {}", jobId);

				SQL = "DELETE FROM ART_JOBS_PARAMETERS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();

				//delete user-jobs records
				SQL = "DELETE FROM ART_USER_JOBS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();

				//delete user group-jobs records
				SQL = "DELETE FROM ART_USER_GROUP_JOBS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();
			}
			ps.close();

			// Delete the Cached table if this job is a cache result one
			if (jobType == 9 || jobType == 10) {
				// Delete
				int targetDatabaseId = Integer.parseInt(outputFormat);
				Connection cacheDatabaseConnection = DbConnections.getConnection(targetDatabaseId);
				CachedResult cr = new CachedResult();
				cr.setTargetConnection(cacheDatabaseConnection);
				if (cachedTableName == null || cachedTableName.length() == 0) {
					cachedTableName = queryName + "_J" + jobId;
				}
				cr.setCachedTableName(cachedTableName);
				cr.drop();
				cacheDatabaseConnection.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close(); // art repository
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Load an existing Job (to update/save/execute). An existing Job is loaded
	 * from the database. Use the getXyz methods to get current properties and
	 * setXyx method to modify properties; then save() to commit the changes on
	 * the database.
	 *
	 * @param jId
	 */
	public void load(int jId) {
		load(jId, username); // if username is not null this job is loaded only if the existing job username matches this job username
	}

	/**
	 *
	 * @param jId
	 * @param usr
	 */
	public void load(int jId, String usr) {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = DbConnections.getArtDbConnection();

			logger.debug("Loading job. Job Id={}, User={}", jId, usr);

			String sql = "SELECT aj.QUERY_ID, aj.USERNAME, aj.OUTPUT_FORMAT, aj.JOB_TYPE,"
					+ " aj.MAIL_TOS, aj.MAIL_FROM, aj.MESSAGE, "
					+ " aj.JOB_MINUTE, aj.JOB_HOUR, aj.JOB_DAY, aj.JOB_WEEKDAY,"
					+ " aj.JOB_MONTH, aj.ENABLE_AUDIT , aj.ACTIVE_STATUS AS JOB_ACTIVE_STATUS,"
					+ " aj.SUBJECT, aq.NAME AS QUERY_NAME, aq.QUERY_TYPE, "
					+ " aq.SHORT_DESCRIPTION, aq.X_AXIS_LABEL, aq.Y_AXIS_LABEL,"
					+ " aq.GRAPH_OPTIONS, aq.USES_RULES, "
					+ " aj.ALLOW_SHARING, aj.ALLOW_SPLITTING, aj.MAIL_CC, aj.MAIL_BCC,"
					+ " aj.RECIPIENTS_QUERY_ID, aj.NEXT_RUN_DATE, aj.START_DATE, aj.END_DATE, "
					+ " aj.MIGRATED_TO_QUARTZ, aq.ACTIVE_STATUS AS QUERY_ACTIVE_STATUS,"
					+ " aj.LAST_FILE_NAME, aj.CACHED_TABLE_NAME, aj.JOB_NAME, "
					+ " au.ACTIVE_STATUS AS OWNER_ACTIVE_STATUS, aj.RUNS_TO_ARCHIVE "
					+ " FROM ART_JOBS aj, ART_QUERIES aq, ART_USERS au"
					+ " WHERE aq.QUERY_ID = aj.QUERY_ID AND aj.USERNAME=au.USERNAME"
					+ " AND aj.JOB_ID = ? "
					+ (usr != null ? "  AND aj.USERNAME = ? " : "");

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jId);

			if (usr != null) {
				ps.setString(2, usr);
			}

			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				logger.debug("Job Found: {}", jId);

				jobId = jId;
				setQueryId(rs.getInt("QUERY_ID"));
				setUsername(rs.getString("USERNAME"));
				setOutputFormat(rs.getString("OUTPUT_FORMAT"));
				setJobType(rs.getInt("JOB_TYPE"));
				setTos(rs.getString("MAIL_TOS"));
				setFrom(rs.getString("MAIL_FROM"));
				setMessage(rs.getString("MESSAGE"));
				setMinute(rs.getString("JOB_MINUTE"));
				setHour(rs.getString("JOB_HOUR"));
				setDay(rs.getString("JOB_DAY"));
				setWeekday(rs.getString("JOB_WEEKDAY"));
				setMonth(rs.getString("JOB_MONTH"));
				setEnableAudit(rs.getString("ENABLE_AUDIT"));
				setActiveStatus(rs.getString("JOB_ACTIVE_STATUS"));
				setSubject(rs.getString("SUBJECT"));
				setQueryName(rs.getString("QUERY_NAME"));
				setQueryType(rs.getInt("QUERY_TYPE"));

				//values to be used with charts
				queryShortDescription = rs.getString("SHORT_DESCRIPTION");
				xAxisLabel = rs.getString("X_AXIS_LABEL");
				yAxisLabel = rs.getString("Y_AXIS_LABEL");
				queryGraphOptions = rs.getString("GRAPH_OPTIONS");

				setQueryRulesFlag(rs.getString("USES_RULES"));
				setAllowSharing(rs.getString("ALLOW_SHARING"));
				setAllowSplitting(rs.getString("ALLOW_SPLITTING"));
				cc = rs.getString("MAIL_CC");
				bcc = rs.getString("MAIL_BCC");
				recipientsQueryId = rs.getInt("RECIPIENTS_QUERY_ID");
				setNextRunDate(rs.getTimestamp("NEXT_RUN_DATE"));
				setStartDate(rs.getDate("START_DATE"));
				setEndDate(rs.getDate("END_DATE"));
				setMigratedToQuartz(rs.getString("MIGRATED_TO_QUARTZ"));
				setQueryStatus(rs.getString("QUERY_ACTIVE_STATUS"));
				setLastFileName(rs.getString("LAST_FILE_NAME"));
				setCachedTableName(rs.getString("CACHED_TABLE_NAME"));
				setJobName(rs.getString("JOB_NAME"));
				jobOwnerStatus = rs.getString("OWNER_ACTIVE_STATUS");
				runsToArchive = rs.getInt("RUNS_TO_ARCHIVE");

				//update from address in case the user's email address has changed
				UserEntity ue = new UserEntity(username);
				String currentEmail = ue.getEmail();
				if (StringUtils.length(currentEmail) > 4) {
					setFrom(currentEmail);
				}
			}
			rs.close();
		} catch (SQLException e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

	}

	/**
	 * Reset Job attributes. This is used to "empty" an existing ArtJob object
	 * in order to re-use it to save another job. Used in editJob.jsp to make
	 * sure a cached ArtJob is not considered when creating a new schduled job
	 */
	public void reset() {
		jobId = -1;
		queryType = 0;
		queryId = -1;
		outputFormat = null;
		tos = null;
		message = null;
		subject = null;
		cachedTableName = null;
	}

	/**
	 *
	 * @param hashInline
	 * @param hashMulti
	 */
	public void setParameters(Map<String, String> hashInline, Map<String, String[]> hashMulti) {
		inlineParams = hashInline;
		multiParams = hashMulti;
	}

	/**
	 * Build job parameters
	 */
	public void buildParameters(int qId) {

		Connection conn = null;

		try {
			//Collect the parameters from the database
			multiParams = null;
			inlineParams = null;
			displayParams = null;
			htmlParams = null;

			multiParams = new HashMap<String, String[]>();
			inlineParams = new HashMap<String, String>();

			ArtQuery aq = new ArtQuery();
			htmlParams = aq.getHtmlParams(qId);

			conn = ArtConfig.getConnection();

			String sql = "SELECT PARAM_TYPE, PARAM_NAME, PARAM_VALUE"
					+ " FROM ART_JOBS_PARAMETERS "
					+ " WHERE JOB_ID = ?"
					+ " ORDER BY PARAM_TYPE, PARAM_NAME";

			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);

			ResultSet rs = ps.executeQuery();

			StringArray sa = new StringArray();
			String name;

			String paramType;
			String paramName;
			String paramValue;

			//put the parameters in maps
			while (rs.next()) {
				paramType = rs.getString("PARAM_TYPE");
				paramName = rs.getString("PARAM_NAME");
				paramValue = rs.getString("PARAM_VALUE");

				//build hash tables
				if (StringUtils.equals(paramType, "I")) {
					inlineParams.put(paramName, paramValue);

					//set parameter value in htmlparams map
					ArtQueryParam aqp = htmlParams.get("P_" + paramName);
					if (aqp != null) {
						aqp.setParamValue(paramValue);
					}
				} else if (StringUtils.equals(paramType, "M")) {
					name = paramName;
					sa.add(paramValue);
					while (rs.next()) {
						logger.debug("Job Id {}. Multi parameter: {}", jobId, name);

						paramName = rs.getString("PARAM_NAME");
						paramValue = rs.getString("PARAM_VALUE");

						if (paramName.equals(name)) {
							sa.add(paramValue);
						} else {
							logger.debug("Job Id {}. Adding Multi to Hash: {}", jobId, name);

							multiParams.put(name, sa.getStringArray());
							name = paramName;
							sa = new StringArray();
							sa.add(paramValue);
						}
					}

					logger.debug("Job Id {}. Adding Multi to Hash: {}", jobId, name);
					if (logger.isDebugEnabled()) {
						for (int i = 0; i < sa.length(); i++) {
							logger.debug("Job Id {}. Value: {}", sa.get(i));
						}
					}

					String[] paramValues = sa.getStringArray();
					multiParams.put(name, paramValues);

					//set parameter value in htmlparams map
					ArtQueryParam aqp = htmlParams.get("M_" + paramName);
					if (aqp != null) {
						aqp.setParamValue(paramValues);
					}
				} else if (StringUtils.equals(paramType, "O")) {
					//other parameters					
					if (StringUtils.equals(paramName, "_showParams")) {
						//enable display of parameters in output
						showParameters = true;
					} else if (StringUtils.equals(paramName, "_showGraphData")) {
						//enable display of graph data in pdf graph output
						showGraphData = true;
					} else if (StringUtils.equals(paramName, "_showGraphDataPoints")) {
						//enable display of graph data points
						showGraphDataPoints = true;
					} else if (StringUtils.equals(paramName, "_showGraphLegend")) {
						//enable display of graph legend
						showGraphLegend = true;
					} else if (StringUtils.equals(paramName, "_showGraphLabels")) {
						//enable display of graph labels
						showGraphLabels = true;
					} else if (StringUtils.equals(paramName, "_graphOptions")) {
						//enable use of custom graph options
						jobGraphOptions = paramValue;
					}
				}
			}
			rs.close();
			ps.close();

			//enable show parameters in job output            
			if (showParameters) {
				displayParams = new TreeMap<Integer, ArtQueryParam>();

				String htmlName;
				String value;
				String label;
				for (Map.Entry<String, String> entry : inlineParams.entrySet()) {
					label = entry.getKey();
					value = entry.getValue();

					htmlName = "P_" + label;

					ArtQueryParam param = htmlParams.get(htmlName);
					if (param != null) {
						//for dynamic date values e.g. ADD... ensure what is used to execute the query is same as what is displayed
						String paramDataType = param.getParamDataType();
						if (StringUtils.startsWith(paramDataType, "DATE")) {
							String dateFormat;
							if (paramDataType.equals("DATE")) {
								dateFormat = "yyyy-MM-dd";
							} else {
								dateFormat = "yyyy-MM-dd HH:mm:ss";
							}
							java.util.Date defaultDate = ReportRunner.getDefaultValueDate(value);
							SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);
							value = dateFormatter.format(defaultDate);

							//update inline param
							inlineParams.put(label, value);
						}
						param.setParamValue(value);

						//for lov parameters, show both parameter value and friendly value
						if (param.usesLov()) {
							//get all possible lov values.							
							try {
								ReportRunner pq = new ReportRunner();
								pq.setReportId(param.getLovQueryId());
								Map<String, String> lov = pq.getLovValues(false); //don't apply rules
								param.setLovValues(lov);
							} catch (Exception e) {
								logger.error("Error", e);
							}
						}
						displayParams.put(param.getFieldPosition(), param);
					}

				}

				String[] values;
				for (Map.Entry<String, String[]> entry : multiParams.entrySet()) {
					label = entry.getKey();
					values = entry.getValue();

					htmlName = "M_" + label;

					ArtQueryParam param = htmlParams.get(htmlName);
					if (param != null) {
						param.setParamValue(values);

						//for lov parameters, show both parameter value and friendly value
						if (param.usesLov()) {
							//get all possible lov values.							
							try {
								ReportRunner pq = new ReportRunner();
								pq.setReportId(param.getLovQueryId());
								Map<String, String> lov = pq.getLovValues(false); //don't apply rules
								param.setLovValues(lov);
							} catch (Exception e) {
								logger.error("Error", e);
							}
						}

						displayParams.put(param.getFieldPosition(), param);
					}

				}
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

	}

	/**
	 * Build string to be used to display parameters in the myjobs.jsp and
	 * sharedjobs.jsp pages
	 */
	public void buildParametersDisplayString() {

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			//get the parameters from the database
			conn = ArtConfig.getConnection();

			String sql = "SELECT PARAM_NAME, PARAM_VALUE"
					+ " FROM ART_JOBS_PARAMETERS "
					+ " WHERE JOB_ID = ?"
					+ " ORDER BY PARAM_TYPE, PARAM_NAME";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);

			ResultSet rs = ps.executeQuery();

			int paramCount = 0;

			StringBuilder sb = new StringBuilder(200);
			sb.append("<br><i>Parameters:</i><br>");

			while (rs.next()) {
				paramCount++;

				//set display string
				sb.append("<b>");
				sb.append(rs.getString("PARAM_NAME"));
				sb.append(":</b>&nbsp;");
				sb.append(rs.getString("PARAM_VALUE"));
				sb.append("<br>");
			}
			rs.close();

			if (paramCount == 0) {
				parametersDisplayString = "";
			} else {
				parametersDisplayString = sb.toString();
			}

		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

	}

	private ReportRunner prepareQuery(String user) throws SQLException {
		return prepareQuery(user, queryId, true);
	}

	/**
	 * Prepares a job for its execution Loads additional info needed to execute
	 * (immediately) the job (query id, datasource etc).
	 */
	private ReportRunner prepareQuery(String user, int qId, boolean buildParams) throws SQLException {
		logger.debug("Job Id {}. prepare()", jobId);

		//build parameter objects from parameters saved in the database
		if (buildParams) {
			buildParameters(qId);
		}

		ReportRunner pq = new ReportRunner();
		pq.setUsername(user);
		pq.setReportId(qId);
		pq.setAdminSession(false);
		pq.setInlineParams(inlineParams);
		pq.setMultiParams(multiParams);
		pq.setHtmlParams(htmlParams);

		logger.debug("Job Id {}. prepare() finished", jobId);

		return pq;

	}

	private synchronized int allocateNewId(Connection conn) throws SQLException {

		Statement st = null;
		PreparedStatement ps = null;
		int newJobId = 1;

		try {
			// Get the id
			st = conn.createStatement();
			ResultSet rs = st.executeQuery("SELECT MAX(JOB_ID) FROM ART_JOBS");

			if (rs.next()) {
				newJobId = 1 + rs.getInt(1);
			} else {
				logger.warn("Job allocateNewJobId failed. Defaulting to 1");
			}
			rs.close();

			//Allocating First
			String sql = "INSERT INTO ART_JOBS (JOB_ID, QUERY_ID, USERNAME, OUTPUT_FORMAT"
					+ " , JOB_TYPE, ACTIVE_STATUS, ENABLE_AUDIT, MIGRATED_TO_QUARTZ) "
					+ " VALUES (?,0,'allocating','html',1, 'Y','N','X') ";
			ps = conn.prepareStatement(sql);
			ps.setInt(1, newJobId);
			ps.executeUpdate();
		} finally {
			try {
				if (st != null) {
					st.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

		return newJobId;
	}

	private Mailer getMailer() {
		Mailer mailer = new Mailer();
		
		mailer.setHost(ArtConfig.getSettings().getSmtpServer());
		mailer.setPort(ArtConfig.getSettings().getSmtpPort());
		mailer.setUseStartTls(ArtConfig.getSettings().isSmtpUseStartTls());
		mailer.setUseAuthentication(ArtConfig.getSettings().isUseSmtpAuthentication());
		mailer.setUsername(ArtConfig.getSettings().getSmtpUsername());
		mailer.setPassword(ArtConfig.getSettings().getSmtpPassword());

		return mailer;
	}

	/**
	 * Migrate existing jobs created in art versions before 1.11 to quartz jobs
	 *
	 */
	public void migrateJobsToQuartz() {

		Connection conn = ArtConfig.getConnection();
		org.quartz.Scheduler scheduler = SchedulerUtils.getScheduler();

		if (conn == null) {
			logger.info("Can't migrate jobs to Quartz. Connection to ART repository not available");
		} else if (scheduler == null) {
			logger.info("Can't migrate jobs to Quartz. Scheduler not available");
		}

		if (scheduler == null || conn == null) {
			return;
		}

		try {
			String oldJobsSqlString;
			String updateJobSqlString;
			PreparedStatement psUpdate;

			//prepare statement for updating migration status			
			updateJobSqlString = "UPDATE ART_JOBS SET MIGRATED_TO_QUARTZ='Y',"
					+ " NEXT_RUN_DATE=?, JOB_MINUTE=?, JOB_HOUR=?, "
					+ " JOB_DAY=?, JOB_WEEKDAY=?, JOB_MONTH=? "
					+ " WHERE JOB_ID=?";
			psUpdate = conn.prepareStatement(updateJobSqlString);

			//determine the jobs to migrate
			oldJobsSqlString = "SELECT JOB_MINUTE, JOB_HOUR, JOB_MONTH, JOB_DAY,"
					+ " JOB_WEEKDAY, JOB_ID "
					+ " FROM ART_JOBS"
					+ " WHERE MIGRATED_TO_QUARTZ='N'";

			PreparedStatement ps = conn.prepareStatement(oldJobsSqlString);
			ResultSet rs = ps.executeQuery();

			String minute;
			String hour;
			String day;
			String weekday;
			String month;
			String second = "0"; //seconds always 0
			String cronString;
			java.util.Date nextRunDate;

			int jobId;
			String jobName;
			String triggerName;

			int totalRecordCount = 0; //total number of jobs to be migrated
			int migratedRecordCount = 0; //actual number of jobs migrated
			final int batchSize = 100; //max number of updates to batch together for executebatch

			while (rs.next()) {
				totalRecordCount += 1;

				//create quartz job
				minute = rs.getString("JOB_MINUTE");
				if (minute == null) {
					minute = "0"; //default to 0
				}
				hour = rs.getString("JOB_HOUR");
				if (hour == null) {
					hour = "3"; //default to 3am
				}
				month = rs.getString("JOB_MONTH");
				if (month == null) {
					month = "*"; //default to every month
				}
				//set day and weekday
				day = rs.getString("JOB_DAY");
				if (day == null) {
					day = "*";
				}
				weekday = rs.getString("JOB_WEEKDAY");
				if (weekday == null) {
					weekday = "?";
				}

				//set default day of the month if weekday is defined
				if (day.length() == 0 && weekday.length() >= 1 && !weekday.equals("?")) {
					//weekday defined but day of the month is not. default day to ?
					day = "?";
				}

				if (day.length() == 0) {
					//no day of month defined. default to *
					day = "*";
				}
				if (weekday.length() == 0) {
					//no day of week defined. default to undefined
					weekday = "?";
				}
				if (day.equals("?") && weekday.equals("?")) {
					//unsupported. only one can be ?
					day = "*";
					weekday = "?";
				}
				if (day.equals("*") && weekday.equals("*")) {
					//unsupported. only one can be defined
					day = "*";
					weekday = "?";
				}

				cronString = second + " " + minute + " " + hour + " " + day + " " + month + " " + weekday;
				if (CronExpression.isValidExpression(cronString)) {
					//ensure that trigger will fire at least once in the future
					CronTrigger tempTrigger = newTrigger().withSchedule(cronSchedule(cronString)).build();

					nextRunDate = tempTrigger.getFireTimeAfter(new java.util.Date());
					if (nextRunDate != null) {
						//create job
						migratedRecordCount += 1;
						if (migratedRecordCount == 1) {
							logger.info("Migrating jobs to quartz...");
						}

						jobId = rs.getInt("JOB_ID");
						jobName = "job" + jobId;
						triggerName = "trigger" + jobId;

						JobDetail quartzJob = newJob(ArtJob.class).withIdentity(jobName, ArtUtils.JOB_GROUP).usingJobData("jobid", jobId).build();

						//create trigger that defines the schedule for the job						
						CronTrigger trigger = newTrigger().withIdentity(triggerName, ArtUtils.TRIGGER_GROUP).withSchedule(cronSchedule(cronString)).build();

						//delete any existing jobs or triggers with the same id before adding them to the scheduler
						scheduler.deleteJob(jobKey(jobName, ArtUtils.JOB_GROUP)); //delete job records
						scheduler.unscheduleJob(triggerKey(triggerName, ArtUtils.TRIGGER_GROUP)); //delete any trigger records

						//add job and trigger to scheduler
						scheduler.scheduleJob(quartzJob, trigger);

						//update jobs table to indicate that the job has been migrated						
						psUpdate.setTimestamp(1, new java.sql.Timestamp(nextRunDate.getTime()));
						psUpdate.setString(2, minute);
						psUpdate.setString(3, hour);
						psUpdate.setString(4, day);
						psUpdate.setString(5, weekday);
						psUpdate.setString(6, month);
						psUpdate.setInt(7, jobId);

						psUpdate.addBatch();
						//run executebatch periodically to prevent out of memory errors
						if (migratedRecordCount % batchSize
								== 0) {
							ps.executeBatch();
							ps.clearBatch(); //not sure if this is necessary
						}
					}
				}
			}
			if (migratedRecordCount > 0) {
				psUpdate.executeBatch(); //run any remaining updates																
			}
			psUpdate.close();

			rs.close();
			ps.close();

			if (migratedRecordCount > 0) {
				//output the number of jobs migrated
				logger.info("Finished migrating jobs to quartz. Migrated {} out of {} jobs", migratedRecordCount, totalRecordCount);
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to users
	 *
	 * @param action
	 * @param users
	 */
	public void updateUserAccess(String action, String[] users) {

		if (action == null || users == null) {
			return;
		}

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_JOBS (USERNAME,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_USER_JOBS WHERE USERNAME = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < users.length; i++) {
				ps.setString(1, users[i]);
				ps.setInt(2, jobId);
				try {
					ps.executeUpdate();
				} catch (SQLIntegrityConstraintViolationException e) {
					logger.info("Access to Job ID {} already granted to User {}", jobId, users[i]);
				} catch (SQLException e) {
					logger.warn("Error. Job id={}, User={}", new Object[]{jobId, users[i], e});
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to users
	 *
	 * @param action
	 * @param users
	 * @param jobs
	 */
	public void updateUserAccess(String action, String[] users, String[] jobs) {

		if (action == null || users == null || jobs == null) {
			return;
		}

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_JOBS (USERNAME, JOB_ID) values (? , ? )";
			} else {
				sql = "DELETE FROM ART_USER_JOBS WHERE USERNAME = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < jobs.length; i++) {
				for (int j = 0; j < users.length; j++) {
					ps.setString(1, users[j]);
					ps.setInt(2, Integer.parseInt(jobs[i]));
					try {
						ps.executeUpdate();
					} catch (SQLIntegrityConstraintViolationException e) {
						logger.info("Access to Job ID {} already granted to User {}", jobId, users[i]);
					} catch (SQLException e) {
						logger.warn("Error. Job id={}, User={}", new Object[]{jobs[i], users[j], e});
					}
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

	}

	/**
	 * Grant or revoke access to user groups
	 *
	 * @param action
	 * @param groups
	 */
	public void updateUserGroupAccess(String action, String[] groups) {

		if (action == null || groups == null) {
			return;
		}

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_GROUP_JOBS (USER_GROUP_ID,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_USER_GROUP_JOBS WHERE USER_GROUP_ID = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < groups.length; i++) {
				ps.setInt(1, Integer.parseInt(groups[i]));
				ps.setInt(2, jobId);
				try {
					ps.executeUpdate();
				} catch (SQLIntegrityConstraintViolationException e) {
					logger.info("Access to Job ID {} already granted to User Group ID {}", jobId, groups[i]);
				} catch (SQLException e) {
					logger.warn("Error. Job id={}, Group id={}", new Object[]{jobId, groups[i], e});
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to user groups
	 *
	 * @param action
	 * @param groups
	 * @param jobs
	 */
	public void updateUserGroupAccess(String action, String[] groups, String[] jobs) {

		if (action == null || groups == null || jobs == null) {
			return;
		}

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_GROUP_JOBS (USER_GROUP_ID,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_USER_GROUP_JOBS WHERE USER_GROUP_ID = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < jobs.length; i++) {
				for (int j = 0; j < groups.length; j++) {
					//remove records in art_user_jobs table for users who have been denied access because their user group has been denied access
					//must be done before the job group record is deleted
					if (action.equals("REVOKE")) {
						removeSharedJobUsers(conn, Integer.parseInt(jobs[i]), Integer.parseInt(groups[j]));
					}

					ps.setInt(1, Integer.parseInt(groups[j]));
					ps.setInt(2, Integer.parseInt(jobs[i]));
					try {
						ps.executeUpdate();
					} catch (SQLIntegrityConstraintViolationException e) {
						logger.info("Access to Job ID {} already granted to User Group ID {}", jobs[i], groups[j]);
					} catch (SQLException e) {
						logger.warn("Error. Job id={}, Group id={}", new Object[]{jobs[i], groups[j], e});
					}
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Get an indicator of jobs and the users and user groups they have been
	 * shared with
	 *
	 * @return jobs and the users and user groups they have been shared with
	 */
	public Map<Integer, String> getSharedJobAssignment() {
		TreeMap<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;
			Integer count = 0; //to ensure items are displayed starting with users then user groups

			//get jobs which have been shared with users
			sql = "SELECT auj.USERNAME, AJ.JOB_ID, AJ.JOB_NAME "
					+ " FROM ART_USER_JOBS auj, ART_JOBS AJ "
					+ " WHERE auj.JOB_ID=AJ.JOB_ID "
					+ " ORDER BY auj.USERNAME";

			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("USERNAME") + " - " + "Job " + rs.getInt("JOB_ID")
						+ " (" + rs.getString("JOB_NAME") + ")";
				map.put(count, tmp);
			}
			rs.close();
			ps.close();

			//get jobs which have been shared with user groups
			sql = "SELECT AUG.NAME, AJ.JOB_ID, AJ.JOB_NAME "
					+ " FROM ART_USER_GROUP_JOBS AUGJ, ART_USER_GROUPS AUG, ART_JOBS AJ "
					+ " WHERE AUGJ.USER_GROUP_ID=AUG.USER_GROUP_ID "
					+ " AND AUGJ.JOB_ID=AJ.JOB_ID "
					+ " ORDER BY AUG.NAME";

			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = "[" + rs.getString("NAME") + "] - " + "Job " + rs.getInt("JOB_ID")
						+ " (" + rs.getString("JOB_NAME") + ")";
				map.put(count, tmp);
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

		return map;
	}

	//get emails for shared job users
	private String getSharedJobEmails() {
		String emails;

		Connection conn = null;
		StringBuilder sb = new StringBuilder(100);

		try {
			conn = ArtConfig.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;

			//get emails from shared job groups
			sql = "SELECT DISTINCT AU.EMAIL "
					+ " FROM ART_USER_GROUP_JOBS AUGJ, ART_USER_GROUP_ASSIGNMENT AUGA, ART_USERS AU "
					+ " WHERE AUGJ.USER_GROUP_ID=AUGA.USER_GROUP_ID AND AUGA.USERNAME=AU.USERNAME "
					+ " AND AUGJ.JOB_ID=?";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);

			rs = ps.executeQuery();
			while (rs.next()) {
				tmp = rs.getString("EMAIL");
				if (StringUtils.length(tmp) > 4) {
					sb.append(tmp).append(";");
				}
			}
			rs.close();
			ps.close();

			//get emails from shared users
			sql = " SELECT DISTINCT au.EMAIL "
					+ " FROM ART_USER_JOBS auj, ART_USERS au "
					+ " WHERE auj.USERNAME=au.USERNAME "
					+ " AND auj.JOB_ID=?";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				tmp = rs.getString("EMAIL");
				if (StringUtils.length(tmp) > 4) {
					sb.append(tmp).append(";");
				}
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

		emails = sb.toString() + tos;

		return emails;
	}

	/**
	 * Get an indicator of which users this job has been shared with
	 *
	 * @return an indicator of which users this job has been shared with
	 */
	public Map<Integer, String> getSharedUsers() {
		Map<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;
			ResultSet rs;
			String tmp;
			Integer count = 0;

			sql = "SELECT DISTINCT USERNAME "
					+ " FROM ART_USER_JOBS "
					+ " WHERE JOB_ID=? "
					+ " ORDER BY USERNAME";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("USERNAME");
				map.put(count, tmp);
			}
			rs.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}

		return map;
	}

	/**
	 * Get an indicator of which user groups this job has been shared with
	 *
	 * @return an indicator of which user groups this job has been shared with
	 */
	public Map<Integer, String> getSharedUserGroups() {
		Map<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;
			ResultSet rs;
			String tmp;
			Integer count = 0;

			sql = "SELECT DISTINCT aug.NAME "
					+ " FROM ART_USER_GROUP_JOBS augj, ART_USER_GROUPS aug "
					+ " WHERE augj.USER_GROUP_ID=aug.USER_GROUP_ID"
					+ " AND augj.JOB_ID=? "
					+ " ORDER BY aug.NAME";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("NAME");
				map.put(count, tmp);
			}
			rs.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (ps != null) {
					ps.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}

		return map;
	}

	/**
	 * Update job archives table
	 */
	private void updateArchives(boolean splitJob, String user, String archiveFileName,
			Timestamp lastStartDate, Timestamp lastEndDate) {

		Connection conn = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;

			boolean jobShared = false;
			if (StringUtils.equals(allowSharing, "Y")) {
				jobShared = true;
			}

			String jobSharedFlag;
			if (splitJob) {
				jobSharedFlag = "S";
			} else if (jobShared) {
				jobSharedFlag = "Y";
			} else {
				jobSharedFlag = "N";
			}

			String archiveId = generateKey();

			//add record to archive
			sql = "INSERT INTO ART_JOB_ARCHIVES"
					+ " (ARCHIVE_ID,JOB_ID,USERNAME,ARCHIVE_FILE_NAME,"
					+ " START_DATE,END_DATE,JOB_SHARED)"
					+ " VALUES(?,?,?,?,?,?,?)";

			ps = conn.prepareStatement(sql);
			ps.setString(1, archiveId);
			ps.setInt(2, jobId);
			ps.setString(3, user);
			ps.setString(4, archiveFileName);
			ps.setTimestamp(5, lastStartDate);
			ps.setTimestamp(6, lastEndDate);
			ps.setString(7, jobSharedFlag);

			ps.executeUpdate();
			ps.close();

			//delete previous run's records
			List<String> oldRecords = new ArrayList<String>();
			if (jobSharedFlag.equals("S")) {
				sql = "SELECT ARCHIVE_ID, ARCHIVE_FILE_NAME "
						+ " FROM ART_JOB_ARCHIVES "
						+ " WHERE JOB_ID=? AND USERNAME=?"
						+ " ORDER BY START_DATE DESC";

				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, user);

				rs = ps.executeQuery();
				int count = 0;
				while (rs.next()) {
					count++;
					if (count > runsToArchive) {
						//delete archive file and database record
						String oldArchiveId = rs.getString("ARCHIVE_ID");
						String oldFileName = rs.getString("ARCHIVE_FILE_NAME");

						//remember database record for deletion
						oldRecords.add("'" + oldArchiveId + "'");

						//delete file
						if (oldFileName != null && !oldFileName.startsWith("-")) {
							List<String> details = ArtUtils.getFileDetailsFromResult(oldFileName);
							oldFileName = details.get(0);
							String filePath = ArtConfig.getJobsExportPath() + oldFileName;
							File previousFile = new File(filePath);
							if (previousFile.exists()) {
								previousFile.delete();
							}
						}
					}
				}
				rs.close();
				ps.close();
			} else {
				sql = "SELECT ARCHIVE_ID, ARCHIVE_FILE_NAME "
						+ " FROM ART_JOB_ARCHIVES "
						+ " WHERE JOB_ID=?"
						+ " ORDER BY START_DATE DESC";

				ps.close();
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);

				rs = ps.executeQuery();
				int count = 0;
				while (rs.next()) {
					count++;
					if (count > runsToArchive) {
						//delete archive file and database record
						String oldArchiveId = rs.getString("ARCHIVE_ID");
						String oldFileName = rs.getString("ARCHIVE_FILE_NAME");

						//remember database record for deletion
						oldRecords.add("'" + oldArchiveId + "'");

						//delete file
						if (oldFileName != null && !oldFileName.startsWith("-")) {
							List<String> details = ArtUtils.getFileDetailsFromResult(oldFileName);
							oldFileName = details.get(0);
							String filePath = ArtConfig.getJobsExportPath() + oldFileName;
							File previousFile = new File(filePath);
							if (previousFile.exists()) {
								previousFile.delete();
							}
						}
					}
				}
				rs.close();
				ps.close();
			}

			//delete old archive records
			if (!oldRecords.isEmpty()) {
				String oldRecordsString = StringUtils.join(oldRecords, ",");
				sql = "DELETE FROM ART_JOB_ARCHIVES WHERE ARCHIVE_ID IN(" + oldRecordsString + ")";
				ps = conn.prepareStatement(sql);
				ps.executeUpdate();
				ps.close();
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Delete all records from job archives table for this job id
	 */
	private void deleteArchives() {

		Connection conn = null;

		try {
			conn = ArtConfig.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;

			List<String> oldRecords = new ArrayList<String>();

			sql = "SELECT ARCHIVE_ID, ARCHIVE_FILE_NAME "
					+ " FROM ART_JOB_ARCHIVES "
					+ " WHERE JOB_ID=?";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);

			rs = ps.executeQuery();
			while (rs.next()) {
				//delete archive file and database record
				String oldArchiveId = rs.getString("ARCHIVE_ID");
				String oldFileName = rs.getString("ARCHIVE_FILE_NAME");

				//remember database record for deletion
				oldRecords.add("'" + oldArchiveId + "'");

				//delete file
				if (oldFileName != null && !oldFileName.startsWith("-")) {
					List<String> details = ArtUtils.getFileDetailsFromResult(oldFileName);
					oldFileName = details.get(0);
					String filePath = ArtConfig.getJobsExportPath() + oldFileName;
					File previousFile = new File(filePath);
					if (previousFile.exists()) {
						boolean deleted = previousFile.delete();
						if (!deleted) {
							logger.warn("File not deleted: {}", previousFile);
						}
					}
				}
			}
			rs.close();
			ps.close();

			//delete old archive records
			if (!oldRecords.isEmpty()) {
				String oldRecordsString = StringUtils.join(oldRecords, ",");
				sql = "DELETE FROM ART_JOB_ARCHIVES WHERE ARCHIVE_ID IN(" + oldRecordsString + ")";
				ps = conn.prepareStatement(sql);
				ps.executeUpdate();
				ps.close();
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}
	}
}
