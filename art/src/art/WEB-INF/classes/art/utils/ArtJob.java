/*
 * Copyright (C) 2001/2007  Enrico Liboni  - enrico@computer.org
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation;
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   (version 2) along with this program (see documentation directory);
 *   otherwise, have a look at http://www.gnu.org or write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/* 2007-02-02  john   added editable subject
 2007-05-14  enrico added new type = 5 (mail with html output inside the email)
 filenamecolumn in ART_JOB enlarged so error message can be fully displayed
 2008-04-04  enrico reworkto use this class as a bean
 and allow to edit/run an existing job
 2008-05-06  enrico fixes to support UTF-8 correctly in generated html files and inline emails
 2009-10-20  enrico  fixed weekday (it was weekDay causing the bean to do not populate it)
 on line 321, 376, 300 replaced charset name UTF8 to UTF-8 (utf-8 inline html should be ok now...
 2010-05-01 enrico/timothy added option to handle charts
 */
package art.utils;

import art.graph.ExportGraph;
import art.mail.Mailer;
import art.output.ArtOutHandler;
import art.output.ArtOutputInterface;
import art.output.jasperOutput;
import art.output.jxlsOutput;
import art.servlets.ArtDBCP;
import java.io.*;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import org.apache.commons.lang.StringUtils;
import org.quartz.*;
import static org.quartz.CronScheduleBuilder.cronSchedule;
import static org.quartz.JobBuilder.newJob;
import static org.quartz.JobKey.jobKey;
import static org.quartz.TriggerBuilder.newTrigger;
import static org.quartz.TriggerKey.triggerKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to run scheduled jobs.
 *
 * <br> To run an existing job:
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.start(); // run the job
 * </pre>
 *
 * To delete an existing job
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.delete();
 * </pre>
 *
 * To update an existing job (query parameters can't be updated - delete and
 * recreate if needed)
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.load(jobId)
 * aj.set...
 * ...
 * aj.save()
 * </pre>
 *
 * To create a new job
 * <pre>
 * ArtJob aj = new ArtJob();
 * aj.set...
 * ...
 * //params need to be set apart
 * aj.save()
 * </pre>
 *
 */
public class ArtJob implements Job {

	final static Logger logger = LoggerFactory.getLogger(ArtJob.class);
	String username, outputFormat, tos, from, message, queryName, subject;
	String enableAudit = "N";
	String activeStatus = "A";
	int jobId = -1;
	int queryType = 0;
	int queryId;
	int jobType;
	String jobName;
	String cachedTableName;
	String minute = "";
	String hour = "";
	String day = "";
	String weekday = "";
	String month = "";
	java.util.Date nextRunDate;
	java.util.Date startDate; //date from which the job will start running. will default to the current date
	java.util.Date endDate; //date at which the job will stop running. default will be no end
	String startDateString = ""; //for use from editjob.jsp
	String endDateString = ""; //for use from editjob.jsp
	String allowSharing = "N"; //for shared jobs
	String allowSplitting = "N"; //for shared jobs. to determine if user rule values should be applied
	String queryRulesFlag; //to determine whether to generate multiple outputs for shared jobs
	String migratedToQuartz = "X"; //to indicate that this job doesn't need migration to quartz. migration done for jobs created with ART versions before 1.11
	java.util.Date lastStartDate; //last start time of overall job
	java.util.Date sharedLastStartDate; //last start time of split job for a specific user
	java.util.Date lastEndDate; //last end time of overall job
	java.util.Date sharedLastEndDate; //last end time of split job for a specific user
	String sharedFileName; //file name in shared jobs table. For split jobs. Unique to the user. Result of applying query rule values for a given user
	// fileName will be set to the filename generated by the job, if any (Alerts do not generate files) or to the generated exception.
	// For cached results this contains the table and columns names
	String fileName = "-No File";
	String parametersDisplayString = ""; //string containing job parameters for display in myjobs.jsp page
	//descriptions to set titles for charts when outputting charts to file
	String queryShortDescription;
	String xaxisLabel;
	String yaxisLabel;
	String queryGraphOptions; //graph options defined for the query
	//
	Map<String, String[]> multiParams;
	Map<String, String> inlineParams;
	String queryStatus; //if query is disabled, don't run job
	String lastFileName;
	String exportPath;
	java.sql.Timestamp jobStartDate; //store job start date. relevant for split jobs
	String jobAuditKey = ""; //hold identifier for a job run in the audit table
	String jobOwnerStatus; //if job owner is not active, don't run job
	boolean showParameters; //to enable display of parameters in reports
	Map<Integer, ArtQueryParam> displayParams; //to enable display of parameters in reports
	boolean showGraphData; //to enable display of graph data below graph for pdf output
	private boolean showGraphLegend;
	private boolean showGraphLabels;
	private boolean showGraphDataPoints;
	private String jobGraphOptions; //custom graph options defined for the job
	private String cc;
	private String bcc;
	Map<String, ArtQueryParam> htmlParams;
	private int recipientsQueryId; //to support dynamic recipients

	/**
	 * Instantiate a new "empty" Job (to insert/save) A new Job is created. Use
	 * the setXyx methods to set properties, then save() to store the new job on
	 * the ART repository (Connection c).
	 */
	public ArtJob() {
		exportPath = ArtDBCP.getExportPath();
	}

	/**
	 * @return the recepientsQueryId
	 */
	public int getRecipientsQueryId() {
		return recipientsQueryId;
	}

	/**
	 * @param recepientsQueryId the recepientsQueryId to set
	 */
	public void setRecipientsQueryId(int recipientsQueryId) {
		this.recipientsQueryId = recipientsQueryId;
	}

	/**
	 * @return the cc
	 */
	public String getCc() {
		return cc;
	}

	/**
	 * @param cc the cc to set
	 */
	public void setCc(String cc) {
		this.cc = cc;
	}

	/**
	 * @return the bcc
	 */
	public String getBcc() {
		return bcc;
	}

	/**
	 * @param bcc the bcc to set
	 */
	public void setBcc(String bcc) {
		this.bcc = bcc;
	}

	/**
	 * Get the custom graph options defined for the job
	 *
	 * @return the custom graph options defined for the job
	 */
	public String getJobGraphOptions() {
		return jobGraphOptions;
	}

	/**
	 * Set the custom graph options defined for the job
	 *
	 * @param jobGraphOptions the custom graph options defined for the job
	 */
	public void setJobGraphOptions(String jobGraphOptions) {
		this.jobGraphOptions = jobGraphOptions;
	}

	/**
	 * Determine if graph legend should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphLegend() {
		return showGraphLegend;
	}

	/**
	 * Determine if graph legend should be shown
	 *
	 * @param showGraphLegend
	 */
	public void setShowGraphLegend(boolean showGraphLegend) {
		this.showGraphLegend = showGraphLegend;
	}

	/**
	 * Determine if graph labels should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphLabels() {
		return showGraphLabels;
	}

	/**
	 * Determine if graph labels should be shown
	 *
	 * @param showGraphLabels
	 */
	public void setShowGraphLabels(boolean showGraphLabels) {
		this.showGraphLabels = showGraphLabels;
	}

	/**
	 * Determine if graph data points should be shown
	 *
	 * @return
	 */
	public boolean isShowGraphDataPoints() {
		return showGraphDataPoints;
	}

	/**
	 * Determine if graph data points should be shown
	 *
	 * @param showGraphDataPoints
	 */
	public void setShowGraphDataPoints(boolean showGraphDataPoints) {
		this.showGraphDataPoints = showGraphDataPoints;
	}

	/**
	 * Determine if graph data should be shown below graph for pdf output
	 *
	 * @param value <code>true</code> is graph data should be shown in output
	 */
	public void setShowGraphData(boolean value) {
		showGraphData = value;
	}

	/**
	 * Determine if graph data should be shown below graph for pdf output
	 *
	 * @return <code>true</code> is graph data should be shown in output
	 */
	public boolean isShowGraphData() {
		return showGraphData;
	}

	/**
	 * Determine is parameters should be shown in output
	 *
	 * @param value <code>true</code> is parameters should be shown in output
	 */
	public void setShowParameters(boolean value) {
		showParameters = value;
	}

	/**
	 * Determine is parameters should be shown in output
	 *
	 * @return <code>true</code> is parameters should be shown in output
	 */
	public boolean isShowParameters() {
		return showParameters;
	}

	/**
	 * Set string that displays the job's parameters
	 *
	 * @param value string that displays the job's parameters
	 */
	public void setParametersDisplayString(String value) {
		parametersDisplayString = value;
	}

	/**
	 *
	 * @return string to display job parameter values
	 */
	public String getParametersDisplayString() {
		return parametersDisplayString;
	}

	/**
	 *
	 * @return last end date for shared job
	 */
	public java.util.Date getSharedLastEndDate() {
		return sharedLastEndDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedLastEndDate(java.util.Date value) {
		sharedLastEndDate = value;
	}

	/**
	 *
	 * @return job last end date
	 */
	public java.util.Date getLastEndDate() {
		return lastEndDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastEndDate(java.util.Date value) {
		lastEndDate = value;
	}

	/**
	 *
	 * @return last start date for shared job
	 */
	public java.util.Date getSharedLastStartDate() {
		return sharedLastStartDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedLastStartDate(java.util.Date value) {
		sharedLastStartDate = value;
	}

	/**
	 *
	 * @return shared file name
	 */
	public String getSharedFileName() {
		return sharedFileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setSharedFileName(String value) {
		sharedFileName = value;
	}

	/**
	 *
	 * @return job last start date
	 */
	public java.util.Date getLastStartDate() {
		return lastStartDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastStartDate(java.util.Date value) {
		lastStartDate = value;
	}

	/**
	 *
	 * @return file name in the jobs table
	 */
	public String getFileName() {
		return fileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setFileName(String value) {
		fileName = value;
	}

	/**
	 *
	 * @return job name
	 */
	public String getJobName() {
		if (jobName == null || jobName.trim().length() == 0) {
			jobName = queryName;
		}
		return jobName;
	}

	/**
	 *
	 * @param value
	 */
	public void setJobName(String value) {
		jobName = value;
	}

	/**
	 *
	 * @return allow sharing setting
	 */
	public String getAllowSharing() {
		return allowSharing;
	}

	/**
	 *
	 * @param value
	 */
	public void setAllowSharing(String value) {
		allowSharing = value;
	}

	/**
	 *
	 * @return allow splitting setting
	 */
	public String getAllowSplitting() {
		return allowSplitting;
	}

	/**
	 *
	 * @param value
	 */
	public void setAllowSplitting(String value) {
		allowSplitting = value;
	}

	/**
	 *
	 * @return whether rules should be applied to query
	 */
	public String getQueryRulesFlag() {
		return queryRulesFlag;
	}

	/**
	 *
	 * @param value
	 */
	public void setQueryRulesFlag(String value) {
		queryRulesFlag = value;
	}

	/**
	 *
	 * @return job last file name
	 */
	public String getLastFileName() {
		return lastFileName;
	}

	/**
	 *
	 * @param value
	 */
	public void setLastFileName(String value) {
		lastFileName = value;
	}

	/**
	 *
	 * @return query status
	 */
	public String getQueryStatus() {
		return queryStatus;
	}

	/**
	 *
	 * @param value
	 */
	public void setQueryStatus(String value) {
		queryStatus = value;
	}

	/**
	 *
	 * @return setting indicating whether job has been migrated to quartz
	 */
	public String getMigratedToQuartz() {
		return migratedToQuartz;
	}

	/**
	 *
	 * @param value
	 */
	public void setMigratedToQuartz(String value) {
		migratedToQuartz = value;
	}

	/**
	 *
	 * @return job start date
	 */
	public java.util.Date getStartDate() {
		return startDate;
	}

	/**
	 *
	 * @return job end date
	 */
	public java.util.Date getEndDate() {
		return endDate;
	}

	/**
	 *
	 * @param value
	 */
	public void setStartDate(java.util.Date value) {
		startDate = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setEndDate(java.util.Date value) {
		endDate = value;
	}

	/**
	 * Specifically for use with editjob.jsp. To work around problems with
	 * implicit date-string conversions. Not saved to the database
	 *
	 * @return start date string
	 */
	public String getStartDateString() {
		if (startDateString != null && startDateString.equals("") && startDate != null) {
			//get start date string from the date variable
			SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
			startDateString = dateFormatter.format(startDate);
		}
		return startDateString;
	}

	/**
	 *
	 * @return job end date string
	 */
	public String getEndDateString() {
		if (endDateString != null && endDateString.equals("") && endDate != null) {
			//get end date string from the date variable
			SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
			endDateString = dateFormatter.format(endDate);
		}
		return endDateString;
	}

	/**
	 *
	 * @param value
	 */
	public void setStartDateString(String value) {
		startDateString = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setEndDateString(String value) {
		endDateString = value;
	}
	//

	//generate jobAuditKey to be used to identify a job run in the audit table
	private String generateKey() {
		return UUID.randomUUID().toString();
	}

	/**
	 *
	 * @param date
	 */
	public void setNextRunDate(java.util.Date date) {
		nextRunDate = date;
	}

	/**
	 *
	 * @return next run date
	 */
	public java.util.Date getNextRunDate() {
		return nextRunDate;
	}

	/**
	 *
	 * @param jId
	 */
	public void setJobId(int jId) {
		load(jId); //load so that in editJob.jsp, job details are displayed        
	}

	/**
	 *
	 * @param jId
	 */
	public void setJobIdOnly(int jId) {
		jobId = jId; //set jobid only, without loading all job details
	}

	/**
	 *
	 * @param i
	 */
	public void setQueryId(int i) {
		queryId = i;
	}

	/**
	 *
	 * @param s
	 */
	public void setUsername(String s) {
		username = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setQueryName(String s) {
		queryName = s;
	}

	/**
	 *
	 * @param i
	 */
	public void setQueryType(int i) {
		queryType = i;
	}

	/**
	 *
	 * @return query type
	 */
	public int getQueryType() {
		return queryType;
	}

	/**
	 *
	 * @param s
	 */
	public void setOutputFormat(String s) {
		outputFormat = s;
	}

	/**
	 *
	 * @param i
	 */
	public void setJobType(int i) {
		jobType = i;
	}

	/**
	 *
	 * @param s
	 */
	public void setTos(String s) {
		if (StringUtils.length(s) > 254) {
			s = s.substring(0, 254);
		}
		tos = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setFrom(String s) {
		from = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setSubject(String s) {
		subject = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setMessage(String s) {
		if (StringUtils.length(s) > 4000) {
			s = s.substring(0, 4000);
		}
		message = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setEnableAudit(String s) {
		enableAudit = s;
	}

	/**
	 *
	 * @param s
	 */
	public void setActiveStatus(String s) {
		activeStatus = s;
	}

	/**
	 *
	 * @param value
	 */
	public void setMinute(String value) {
		minute = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setHour(String value) {
		hour = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setDay(String value) {
		day = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setWeekday(String value) {
		weekday = value;
	}

	/**
	 *
	 * @param value
	 */
	public void setMonth(String value) {
		month = value;
	}

	/**
	 *
	 * @return job id
	 */
	public int getJobId() {
		return jobId;
	}

	/**
	 *
	 * @return query id
	 */
	public int getQueryId() {
		return queryId;
	}

	/**
	 *
	 * @return job owner
	 */
	public String getUsername() {
		return username;
	}

	/**
	 *
	 * @return query name
	 */
	public String getQueryName() {
		return queryName;
	}

	/**
	 *
	 * @return output format
	 */
	public String getOutputFormat() {
		return outputFormat;
	}

	/**
	 *
	 * @return job type
	 */
	public int getJobType() {
		return jobType;
	}

	/**
	 *
	 * @return email addresses of recipients
	 */
	public String getTos() {
		return tos;
	}

	/**
	 *
	 * @return from email address
	 */
	public String getFrom() {
		return from;
	}

	/**
	 *
	 * @return subject of email message
	 */
	public String getSubject() {
		return subject;
	}

	/**
	 *
	 * @return email body contents
	 */
	public String getMessage() {
		return message;
	}

	/**
	 *
	 * @return enable audit setting
	 */
	public String getEnableAudit() {
		return enableAudit;
	}

	/**
	 *
	 * @return active status
	 */
	public String getActiveStatus() {
		return activeStatus;
	}

	/**
	 *
	 * @return minute of the day that the job should run
	 */
	public String getMinute() {
		return minute;
	}

	/**
	 *
	 * @return hour of the day that job should run
	 */
	public String getHour() {
		return hour;
	}

	/**
	 *
	 * @return day of the month that job should run
	 */
	public String getDay() {
		return day;
	}

	/**
	 *
	 * @return weekday that job should run
	 */
	public String getWeekday() {
		return weekday;
	}

	/**
	 *
	 * @return month of the year that job should run
	 */
	public String getMonth() {
		return month;
	}

	/**
	 *
	 * @return cached table name
	 */
	public String getCachedTableName() {
		return cachedTableName;
	}

	/**
	 *
	 * @param s
	 */
	public void setCachedTableName(String s) {
		if (s == null) {
			s = "CACHED_TABLE";
		}
		cachedTableName = s.trim();
	}

	/**
	 * execute job
	 *
	 * @param context
	 * @throws JobExecutionException
	 */
	@Override
	public void execute(JobExecutionContext context) throws JobExecutionException {
		JobDataMap dataMap = null;

		int tempJobId = 0;
		if (context != null) {
			dataMap = context.getMergedJobDataMap();
			tempJobId = dataMap.getInt("jobid");

			logger.debug("Attempting to load Job Id {}", tempJobId);

			load(tempJobId);
		}

		if (jobId == -1) {
			//job not found. exit
			logger.debug("Job Id {} not found", tempJobId);
			return;
		}

		logger.debug("Job Id {} running...", jobId);

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			//get next run date	for the job for updating the jobs table. only update if it's a scheduled run and not an interactive, temporary job
			String tempJob = dataMap.getString("tempjob");
			if (tempJob == null) {
				//not a temp job. set next run date
				nextRunDate = context.getTrigger().getFireTimeAfter(new java.util.Date());
			}

			// set overall job start time in the jobs table
			beforeExecution(conn);

			//don't run job if query or job or job owner is disabled
			if (StringUtils.equals("D", jobOwnerStatus)) {
				//job owner disabled. don't run job. just update jobs table with current status
				fileName = "-Job Owner Disabled";
			} else if (StringUtils.equals("D", queryStatus)) {
				//query disabled. don't run job. just update jobs table with current status
				fileName = "-Query Disabled";
			} else if (StringUtils.equals("N", activeStatus)) {
				//job disabled. don't run job. just update jobs table with current status
				fileName = "-Job Disabled";
			} else {
				//run job. handle dynamic recipients
				if (recipientsQueryId > 0) {
					//job has dynamic recipients
					runDynamicRecipientsJob(conn);
				} else {
					//job doesn't have dynamic recipients
					runNormalJob(conn);
				}
			}

			//set job table's final end time and file name
			afterCompletion(conn);

		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				conn.close(); // art repository
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}
	}

	private boolean hasColumn(ResultSet rs, String columnName) {
		boolean hasColumn = false;

		try {
			ResultSetMetaData rsmd = rs.getMetaData();
			int columns = rsmd.getColumnCount();
			for (int x = 1; x <= columns; x++) {
				if (columnName.equals(rsmd.getColumnName(x))) {
					hasColumn = true;
					break;
				}
			}
		} catch (SQLException ex) {
			logger.error("Error", ex);
		}

		return hasColumn;
	}

	private void runDynamicRecipientsJob(Connection conn) {

		PreparedQuery recipientsQuery = null; //recipients query
		try {
			//get recipient data
			recipientsQuery = prepareQuery(username, recipientsQueryId, false);

			recipientsQuery.setAdminSession(true); //don't check security
			recipientsQuery.execute();

			ResultSet rs = recipientsQuery.getResultSet();
			ResultSetMetaData rsmd = rs.getMetaData();
			int columnCount = rsmd.getColumnCount();

			if (columnCount == 1) {
				//only email column. add dynamic recipient emails to Tos and run like normal job
				ArrayList<String> emailsList = new ArrayList<String>();
				while (rs.next()) {
					String email = rs.getString(1); //first column has email addresses
					if (StringUtils.length(email) > 4) {
						emailsList.add(email);
					}
				}
				rs.close();

				if (emailsList.size() > 0) {
					String emails = StringUtils.join(emailsList, ";");
					runNormalJob(conn, emails);
				}
			} else if (columnCount > 1) {
				//personalization fields present
				//Get the column names. column indices start from 1
				ArrayList<String> columnList = new ArrayList<String>();
				for (int i = 1; i < columnCount + 1; i++) {
					String columnName = rsmd.getColumnLabel(i); //use alias if available
					columnList.add(columnName);
				}
				final String RECIPIENT_ID_COLUMN = "recipient_identifier"; //column name in data query that contains recipient identifier column
				final String RECIPIENT_COLUMN = "recipient_column"; //column name in data query that contains recipient identifier
				final String RECIPIENT_LABEL = "#recipient#"; //label for recipient in data query

				if (columnList.contains(RECIPIENT_COLUMN) && columnList.contains(RECIPIENT_ID_COLUMN)) {
					//separate emails, different email message, different report data
				} else {
					//separate emails, different email message, same report data
					Map<String, Map> recipients = new HashMap<String, Map>();
					while (rs.next()) {
						String email = rs.getString(1); //first column has email addresses
						Map<String, String> recipientColumns = new HashMap<String, String>();
						String columnName;
						String columnValue;
						for (int i = 1; i < columnCount; i++) {
							columnName = rsmd.getColumnLabel(i); //use column alias if available

							//column name must exist otherwise rs.getString will throw an exception
							if (rs.getString(columnName) == null) {
								columnValue = "";
							} else {
								columnValue = rs.getString(columnName);
							}
							recipientColumns.put(columnName, columnValue);
						}

						recipients.put(email, recipientColumns);

					}
					rs.close();

					//run job
					runJob(conn, true, username, tos, recipients);
				}
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			if (recipientsQuery != null) {
				recipientsQuery.close();
			}
		}
	}

	private void runNormalJob(Connection conn) {
		runNormalJob(conn, null);
	}

	private void runNormalJob(Connection conn, String dynamicRecipients) {
		//run job. if job isn't shared, generate single output
		//if job is shared and doesn't use rules, generate single output to be used by all users
		//if job is shared and uses rules, generate multiple, individualized output for each shared user

		try {

			int userCount = 0; //number of shared users
			String ownerFileName = null; //for shared jobs, ensure the jobs table has the job owner's file

			boolean splitJob = false; //flag to determine if job will generate one file or multiple individualized files. to know which tables to update

			if (StringUtils.equals(allowSharing, "Y")) {
				if (StringUtils.equals(queryRulesFlag, "Y") && StringUtils.equals(allowSplitting, "Y")) {
					splitJob = true;
				}

				if (splitJob) {
					//generate individualized output for all shared users

					//update shared jobs table with users who have access through group membership. so that users newly added to a group can get their own output
					addSharedJobUsers(conn, jobId);

					//get users to generate output for
					String usersSQL = "SELECT ASJ.USERNAME, AU.EMAIL "
							+ " FROM ART_SHARED_JOBS ASJ, ART_USERS AU "
							+ " WHERE ASJ.USERNAME = AU.USERNAME "
							+ " AND ASJ.JOB_ID = ? AND AU.ACTIVE_STATUS='A'";

					PreparedStatement ps = conn.prepareStatement(usersSQL);
					ps.setInt(1, jobId);

					ResultSet rs = ps.executeQuery();
					while (rs.next()) {
						userCount += 1;
						runJob(conn, false, rs.getString("USERNAME"), rs.getString("EMAIL"));
						//ensure that the job owner's output version is saved in the jobs table
						if (username.equals(rs.getString("USERNAME"))) {
							ownerFileName = fileName;
						}
					}
					rs.close();
					ps.close();

					if (userCount == 0) {
						//no shared users defined yet. generate one file for the job owner
						String emails = tos;
						if (dynamicRecipients != null) {
							emails = emails + ";" + dynamicRecipients;
						}
						runJob(conn, true, username, emails);
					}
				} else {
					//generate one single output to be used by all users
					String emails = getSharedJobEmails();
					if (dynamicRecipients != null) {
						emails = emails + ";" + dynamicRecipients;
					}
					runJob(conn, true, username, emails);
				}
			} else {
				//job isn't shared. generate one file for the job owner
				String emails = tos;
				if (dynamicRecipients != null) {
					emails = emails + ";" + dynamicRecipients;
				}
				runJob(conn, true, username, emails);
			}

			//ensure jobs table always has job owner's file, or a note if no output was produced for the job owner
			if (ownerFileName != null) {
				fileName = ownerFileName;
			} else if (splitJob && userCount > 0 && ownerFileName == null) {
				//job is shared with other users but the owner doesn't have a copy. save note in the jobs table
				fileName = "-Job Shared";
			}
		} catch (Exception e) {
			logger.error("Error", e);
		}
	}

	private void runJob(Connection conn, boolean singleOutput, String user, String userEmail) {
		runJob(conn, singleOutput, user, userEmail, null);
	}

	//run job
	private void runJob(Connection conn, boolean singleOutput, String user, String userEmail, Map<String, Map> recipientDetails) {
		//set job start date. relevant for split jobs
		jobStartDate = new java.sql.Timestamp(new java.util.Date().getTime());

		PreparedQuery pq = null;

		fileName = "-No File"; //reset file name

		//create job audit record if auditing is enabled
		createAuditRecord(conn, user);

		try {
			pq = prepareQuery(user);

			//for split jobs, don't check security for shared users. they have been allowed access to the output
			if (!singleOutput) {
				pq.setAdminSession(true);
			}

			int resultSetType;
			if (queryType < 0) {
				resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE; //need scrollable resultset for graphs for show data option
			} else {
				resultSetType = ResultSet.TYPE_FORWARD_ONLY;
			}

			/*
			 * BEGIN EXECUTE QUERY
			 */

			pq.execute(resultSetType);


			/*
			 * END EXECUTE QUERY
			 */


			/*
			 * Job Types: 1 = Alert 2 = Mails as attachment 3 = Publish 4 = Just
			 * Run 5 = Mail with output within the email as html 6 = Mails as
			 * attachment only if query returns one or more rows 7 = Mail with
			 * output within the email as html only if query returns one or more
			 * rows 8 = Publish only if query returns one or more rows 9 = Cache
			 * the result set in the cache database (append) 10 = Cache the
			 * result set in the cache database (drop/insert)
			 */

			boolean mailSent; //use to check if email was successfully sent

			//trim address fields. to aid in checking if emails are configured
			userEmail = StringUtils.trim(userEmail);
			tos = StringUtils.trim(tos);
			cc = StringUtils.trim(cc);
			bcc = StringUtils.trim(bcc);

			//determine if emailing is required and emails are configured
			boolean generateEmail = false;
			if (jobType == 3 || jobType == 8) {
				//for split published jobs, tos should have a value to enable confirmation email for individual users
				if (!StringUtils.equals(tos, userEmail) && (StringUtils.length(tos) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4) && StringUtils.length(userEmail) > 4) {
					generateEmail = true;
				} else if (StringUtils.equals(tos, userEmail) && (StringUtils.length(tos) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4)) {
					generateEmail = true;
				}
			} else {
				//for non-publish jobs, if an email address is available, generate email
				if (StringUtils.length(userEmail) > 4 || StringUtils.length(cc) > 4 || StringUtils.length(bcc) > 4) {
					generateEmail = true;
				}
			}

			//set email fields
			String[] tosEmail = null;
			String[] ccs = null;
			String[] bccs = null;
			if (generateEmail) {
				tosEmail = StringUtils.split(userEmail, ";");
				ccs = StringUtils.split(cc, ";");
				bccs = StringUtils.split(bcc, ";");

				logger.debug("Job Id {}. to: {}", jobId, userEmail);
				logger.debug("Job Id {}. cc: {}", jobId, cc);
				logger.debug("Job Id {}. bcc: {}", jobId, bcc);
			}

			if (jobType == 1) {
				/*
				 * ALERT if the resultset is not null and the first column is a
				 * positive integer => send the alert email
				 */

				//only run alert query if we have some emails configured
				if (generateEmail || recipientDetails != null) {
					fileName = "-No Alert";

					ResultSet rs = pq.getResultSet();
					if (rs.next()) {
						int value = rs.getInt(1);
						if (value > 0) {
							logger.debug("Job Id {} - Raising Alert. Value is {}", jobId, value);

							// compatibility with Art pre 1.8 where subject was not editable
							if (subject == null) {
								subject = "ART Alert: " + jobName + " (Job " + jobId + ")";
							}

							//send customized emails to dynamic recipients
							if (recipientDetails != null) {
								Mailer m = getMailer();

								Iterator it = recipientDetails.entrySet().iterator();
								while (it.hasNext()) {
									Map.Entry entry = (Map.Entry) it.next();
									String email = (String) entry.getKey();
									Map<String, String> recipientColumns = (Map<String, String>) entry.getValue();

									m.setSubject(subject);
									m.setToForce(email);
									m.setType("text/html;charset=utf-8");
									m.setFrom(from);

									//customize message by replacing field labels with values for this recipient
									String customMessage = message; //message for a particular recipient. may include personalization e.g. Dear Jane
									if (customMessage == null) {
										customMessage = "";
									}

									if (StringUtils.isNotBlank(customMessage)) {
										Iterator it2 = recipientColumns.entrySet().iterator();
										while (it2.hasNext()) {
											Map.Entry entry2 = (Map.Entry) it2.next();
											String columnName = (String) entry2.getKey();
											String columnValue = (String) entry2.getValue();

											customMessage = customMessage.replaceAll("(?i)#" + columnName + "#", columnValue); //(?i) makes regex case insensitive. first parameter of replaceall is a regex expression.
										}
									}

									//set custom message
									m.setMessage("<html>" + customMessage + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job " + jobId + ")</small></html>");

									//send email for this recipient
									m.send();
								}
							}

							if (generateEmail) {
								//send email to normal recipients
								Mailer m = getMailer();

								m.setSubject(subject);

								//set recipients						
								m.setTos(tosEmail);
								m.setCc(ccs);
								m.setBcc(bccs);

								m.setType("text/html;charset=utf-8"); // or m.setType("text/plain");
								m.setFrom(from);
								m.setMessage("<html>" + message + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job " + jobId + ")</small></html>");

								mailSent = m.send(); //check return value to determine if email sent successfully
								if (mailSent) {
									fileName = "-Alert Sent";
								} else {
									fileName = "-Error when sending alert <p>" + m.getSendError() + "</p>";
								}

							} else {
								logger.debug("Job Id {} - No Alert. Value is {}", jobId, value);
							}
						} else {
							logger.debug("Job Id {} - Empty resultset for alert", jobId);
						}
					}
				} else {
					//no emails configured
					fileName = "-No emails configured";
				}
			} else if (jobType == 2 || jobType == 3 || jobType == 5 || jobType == 6 || jobType == 7 || jobType == 8) {
				/*
				 * MAILwithAttachment or PUBLISH or MAILinLine
				 */
				ResultSet rs = null;
				ResultSetMetaData rsmd = null;
				if (queryType != 115 && queryType != 117) {
					rs = pq.getResultSet();
					rsmd = rs.getMetaData();
				}

				logger.debug("Job Id {} - Mail or Publish. Type: {}", jobId, jobType);

				//determine if the query returns records. to know if to generate output for conditional jobs
				boolean generateOutput = true;

				if (jobType == 6 || jobType == 7 || jobType == 8) {
					//conditional job. check if resultset has records. no "recordcount" method so we have to execute query again
					PreparedQuery pqCount = prepareQuery(user);
					pqCount.setAdminSession(true);
					pqCount.execute();
					ResultSet rsCount = pqCount.getResultSet();
					if (!rsCount.next()) {
						//no records
						generateOutput = false;
						fileName = "-No Records";
					}
					rsCount.close();
					pqCount.close();
				}

				//for emailing jobs, only run query if some emails are configured
				if (jobType == 2 || jobType == 5 || jobType == 6 || jobType == 7) {
					//email attachment, email inline, conditional email attachment, conditional email inline
					if (!generateEmail && recipientDetails == null) {
						generateOutput = false;
						fileName = "-No emails configured";
					}
				}

				if (generateOutput) {
					String sep = java.io.File.separator;
					String jobsPath = exportPath + "jobs" + sep;
					String jobFileUsername = "JobId" + jobId;

					if (queryType < 0) {
						//save charts to file
						ExportGraph eg = new ExportGraph();
						eg.setFileUserName(jobFileUsername);
						eg.setQueryName(queryName);
						eg.setExportPath(jobsPath);
						eg.setOutputFormat(outputFormat); // png or pdf
						eg.setXlabel(xaxisLabel);
						eg.setYlabel(yaxisLabel);
						eg.setTitle(queryShortDescription);
						eg.setShowData(showGraphData); //enable display of graph data below graph for pdf graph output
						eg.setDisplayParameters(displayParams); //enable display of graph parameters above graph for pdf graph output
						eg.setShowDataPoints(showGraphDataPoints);
						eg.setShowLegend(showGraphLegend);
						eg.setShowLabels(showGraphLabels);
						eg.setQueryId(queryId);
						eg.setGraphOptions(jobGraphOptions);

						eg.createFile(rs, queryType);
						fileName = eg.getFileName();
					} else if (queryType == 115 || queryType == 116) {
						//jasper report
						jasperOutput jasper = new jasperOutput();
						jasper.setQueryName(queryName);
						jasper.setFileUserName(jobFileUsername);
						jasper.setExportPath(jobsPath);
						jasper.setOutputFormat(outputFormat);

						if (queryType == 115) {
							//report will use query in the report template
							jasper.createFile(null, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						} else {
							//report will use data from art query
							jasper.createFile(rs, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						}
						fileName = jasper.getFileName();
					} else if (queryType == 117 || queryType == 118) {
						//jxls spreadsheet
						jxlsOutput jxls = new jxlsOutput();
						jxls.setQueryName(queryName);
						jxls.setFileUserName(jobFileUsername);
						jxls.setExportPath(jobsPath);

						if (queryType == 117) {
							//report will use query in the jxls template
							jxls.createFile(null, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						} else {
							//report will use data from art query
							jxls.createFile(rs, queryId, pq.getInlineParams(), pq.getMultiParams(), htmlParams);
						}
						fileName = jxls.getFileName();
					} else {
						ArtOutputInterface o;

						String classToLoad = "art.output." + outputFormat + "Output";
						ClassLoader cl = this.getClass().getClassLoader();
						Object obj = cl.loadClass(classToLoad).newInstance();

						o = (ArtOutputInterface) obj;

						o.setMaxRows(ArtDBCP.getMaxRows(outputFormat));

						//printwriter not needed for all output types. Avoid creating extra html file when output is not html, xml or rss
						FileOutputStream fos = null;
						PrintWriter out = null;
						boolean printWriterUsed = false;

						if (outputFormat.indexOf("html") >= 0 || outputFormat.indexOf("xml") >= 0 || outputFormat.indexOf("rss") >= 0) {
							if (outputFormat.indexOf("html") >= 0) {
								queryName = ArtDBCP.cleanFileName(queryName);
								SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy_MM_dd-HH_mm_ss");
								String datePart = dateFormatter.format(new java.util.Date());

								fileName = jobsPath + jobFileUsername + "-" + queryName + "-" + datePart + ArtDBCP.getRandomString() + ".html";
							} else {
								//xml or rss
								fileName = jobsPath + jobFileUsername + ".html";
							}
							fos = new FileOutputStream(fileName);
							out = new PrintWriter(new OutputStreamWriter(fos, "UTF-8")); // make sure we make a utf-8 encoded text
							o.setWriter(out);
							printWriterUsed = true;
						}

						o.setQueryName(queryName);
						o.setFileUserName(jobFileUsername);
						o.setExportPath(jobsPath);
						o.setDisplayParameters(displayParams);

						ResourceBundle messages = ResourceBundle.getBundle("art.i18n.ArtMessages");
						if (queryType == 101 || queryType == 102) {
							ArtOutHandler.flushXOutput(messages, o, rs, rsmd);
						} else {
							ArtOutHandler.flushOutput(messages, o, rs, rsmd);
						}

						/*
						 * Now the resultset has been flushed in the o ArtOutput
						 * object and therefore it has been: 1. streamed in the
						 * out PrintWriter (file) (or) 2. written in another
						 * file if the o object did it (for example xls view
						 * mode) Thus now we need to discover where the output
						 * is (in the out object or in another file)
						 */
						if (o.getFileName() != null) {
							fileName = o.getFileName();
						}

						// the file is on the PrintWriter (for html)
						if (printWriterUsed) {
							out.close();
							fos.close();
						}
					}

					// fileName now stores the file to mail or publish...                    
					logger.debug("Job Id {}. File is: {}", jobId, fileName);

					if (generateEmail || recipientDetails != null) {
						//some kind of emailing required

						// compatibility with Art pre 1.8 where subject was not editable
						if (subject == null) {
							subject = "ART Scheduler: " + jobName + " (Job " + jobId + ")";
						}

						//send customized emails to dynamic recipients
						if (recipientDetails != null) {
							Mailer m = getMailer();

							Iterator it = recipientDetails.entrySet().iterator();
							while (it.hasNext()) {
								Map.Entry entry = (Map.Entry) it.next();
								String email = (String) entry.getKey();
								Map<String, String> recipientColumns = (Map<String, String>) entry.getValue();

								m.setSubject(subject);
								m.setToForce(email);
								m.setType("text/html;charset=utf-8");
								m.setFrom(from);

								//customize message by replacing field labels with values for this recipient
								String customMessage = message; //message for a particular recipient. may include personalization e.g. Dear Jane
								if (customMessage == null) {
									customMessage = "";
								}

								if (StringUtils.isNotBlank(customMessage)) {
									Iterator it2 = recipientColumns.entrySet().iterator();
									while (it2.hasNext()) {
										Map.Entry entry2 = (Map.Entry) it2.next();
										String columnName = (String) entry2.getKey();
										String columnValue = (String) entry2.getValue();

										String searchString = Pattern.quote("#" + columnName + "#"); //quote in case it contains special regex characters
										String replaceString = Matcher.quoteReplacement(columnValue); //quote in case it contains special regex characters
										customMessage = customMessage.replaceAll("(?iu)" + searchString, replaceString);
									}
								}

								if (StringUtils.isBlank(customMessage)) {
									customMessage = "&nbsp;"; //if message is blank, ensure there's a space before the hr
								}

								//set custom message
								if (jobType == 2 || jobType == 6) {
									// e-mail output as attachment
									List<File> l = new ArrayList<File>();
									l.add(new File(fileName));
									m.setAttachments(l);
									m.setMessage("<html>" + customMessage + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
								} else if (jobType == 5 || jobType == 7) {
									// inline html within email
									// read the file and include it in the HTML message
									FileInputStream fis = new FileInputStream(fileName);
									byte fileBytes[] = new byte[fis.available()];
									fis.read(fileBytes);
									// convert the file to a string and get only the html table
									String htmlTable = new String(fileBytes, "UTF-8");
									//htmlTable = htmlTable.substring(htmlTable.indexOf("<html>") + 6, htmlTable.indexOf("</html>"));
									htmlTable = htmlTable.substring(htmlTable.indexOf("<body>") + 6, htmlTable.indexOf("</body>")); //html plain output now has head and body sections
									m.setMessage("<html>" + customMessage + "<hr>" + htmlTable + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
									fis.close();
								} else { // publish
									int retentionPeriod = ArtDBCP.getPublishedFilesRetentionPeriod();

									if (retentionPeriod == 0) {
										m.setMessage("<html>" + customMessage + "<hr><small>This is an automatically generated message. Report has been published. (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
									} else {
										m.setMessage("<html>" + customMessage + "<hr><small>This is an automatically generated message. Report has been published and will be available for the following number of days: " + retentionPeriod + " (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
									}
								}

								//send email for this recipient
								m.send();
							}
						}

						//send email to normal recipients
						if (generateEmail) {
							Mailer m = getMailer();

							m.setSubject(subject);

							//set recipients						
							m.setTos(tosEmail);
							m.setCc(ccs);
							m.setBcc(bccs);

							m.setType("text/html;charset=utf-8"); // 20080314 - hint by josher19 to display chinese correctly in emails
							m.setFrom(from);

							if (StringUtils.isBlank(message)) {
								message = "&nbsp;"; //if message is blank, ensure there's a space before the hr
							}

							if (jobType == 2 || jobType == 6) {
								// e-mail output as attachment
								List<File> l = new ArrayList<File>();
								l.add(new File(fileName));
								m.setAttachments(l);
								m.setMessage("<html>" + message + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
							} else if (jobType == 5 || jobType == 7) {
								// inline html within email
								// read the file and include it in the HTML message
								FileInputStream fis = new FileInputStream(fileName);
								byte fileBytes[] = new byte[fis.available()];
								fis.read(fileBytes);
								// convert the file to a string and get only the html table
								String htmlTable = new String(fileBytes, "UTF-8");
								//htmlTable = htmlTable.substring(htmlTable.indexOf("<html>") + 6, htmlTable.indexOf("</html>"));
								htmlTable = htmlTable.substring(htmlTable.indexOf("<body>") + 6, htmlTable.indexOf("</body>")); //html plain output now has head and body sections
								m.setMessage("<html>" + message + "<hr>" + htmlTable + "<hr><small>This is an automatically generated message (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
								fis.close();
							} else { // publish
								int retentionPeriod = ArtDBCP.getPublishedFilesRetentionPeriod();

								if (retentionPeriod == 0) {
									m.setMessage("<html>" + message + "<hr><small>This is an automatically generated message. Report has been published. (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
								} else {
									m.setMessage("<html>" + message + "<hr><small>This is an automatically generated message. Report has been published and will be available for the following number of days: " + retentionPeriod + " (ART Reporting Tool, Job ID " + jobId + ")</small></html>");
								}
							}

							//check if mail was successfully sent
							mailSent = m.send();
							if (jobType == 2 || jobType == 5 || jobType == 6 || jobType == 7) {
								// delete the file since it has
								// been sent via email (for publish jobs it is deleted by the scheduler)
								File f = new File(fileName);
								f.delete();
								if (mailSent) {
									fileName = "-File has been emailed";
								} else {
									//if multiple recipients, some might have succeeded. no way of knowing which
									fileName = "-Error when sending emails. Some may have succeeded. "
											+ " <p>" + m.getSendError() + "</p>"
											+ " <p>Complete address list:<br>To: " + userEmail + "<br>Cc: " + cc + "</p>";

								}
							} else {
								//publish job reminder email. separate file link and message with a newline character
								if (mailSent) {
									fileName = fileName + System.getProperty("line.separator") + "<p>Reminder email sent</p>";
								} else {
									fileName = fileName + System.getProperty("line.separator") + "<p>Error when sending reminder email <br>" + m.getSendError() + "</p>";
								}
							}
						}
					}
				}

			} else if (jobType == 9 || jobType == 10) {
				// Cache the result in the cache database
				int targetDatabaseId = Integer.parseInt(outputFormat);

				Connection cacheDatabaseConnection = ArtDBCP.getConnection(targetDatabaseId);
				ResultSet rs = pq.getResultSet();
				CachedResult cr = new CachedResult();
				cr.setTargetConnection(cacheDatabaseConnection);
				cr.setResultSet(rs);
				if (cachedTableName == null || cachedTableName.length() == 0) {
					cachedTableName = queryName + "_J" + jobId;
				}
				cr.setCachedTableName(cachedTableName);
				cr.setCacheMode(jobType - 8); // 1 = append 2 = drop/insert (3 = update (not implemented))
				cr.cacheIt();
				cacheDatabaseConnection.close();
				fileName = "- Table Name (rows inserted):  <code>" + cr.getCachedTableName() + "</code> (" + cr.getRowsCount() + ")"
						+ "<br />Columns Names:<br /><code>" + cr.getCachedTableColumnsName() + "</code>";

			} else { // jobType 4:just run it.
				// This is used Used to start batch jobs at db level via calls to stored procs
				// or just to run update statements.
			}

			// set audit timestamp
			afterExecution(conn, singleOutput, user);

			logger.debug("Job Id {} ...finished", jobId);
		} catch (Exception e) {
			logger.error("Error. Job id={}, User={}", new Object[]{jobId, user, e});
			afterExecutionOnException(conn, e, singleOutput, user); // set audit timestamp and log error message
		} finally {
			if (pq != null) {
				pq.close();
			}
		}
	}

	/**
	 * Update shared jobs table with users who have access through group
	 * membership.
	 *
	 * @param conn
	 * @param jId
	 */
	public void addSharedJobUsers(Connection conn, int jId) {
		String sql;
		PreparedStatement ps;
		ResultSet rs;
		PreparedStatement psInsert;

		try {
			//get users who should have access to the job through group membership but don't already have it
			sql = "SELECT AU.USERNAME, AUGA.USER_GROUP_ID "
					+ " FROM ART_USERS AU, ART_USER_GROUP_ASSIGNMENT AUGA, ART_USER_GROUP_JOBS AUGJ "
					+ " WHERE AU.USERNAME = AUGA.USERNAME AND AUGA.USER_GROUP_ID = AUGJ.USER_GROUP_ID "
					+ " AND AUGJ.JOB_ID = ? "
					+ " AND NOT EXISTS "
					+ " (SELECT * FROM ART_SHARED_JOBS ASJ "
					+ " WHERE ASJ.USERNAME = AU.USERNAME AND ASJ.JOB_ID = ?)";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jId);
			ps.setInt(2, jId);
			rs = ps.executeQuery();

			sql = "INSERT INTO ART_SHARED_JOBS (JOB_ID, USERNAME, USER_GROUP_ID) VALUES (?,?,?)";

			psInsert = conn.prepareStatement(sql);
			while (rs.next()) {
				//insert records into the shared jobs table so that the users can have access to the job
				try {
					psInsert.setInt(1, jId);
					psInsert.setString(2, rs.getString("USERNAME"));
					psInsert.setString(3, rs.getString("USER_GROUP_ID"));
					psInsert.executeUpdate();
				} catch (Exception e) {
					logger.error("Error. Job id {}", jobId, e);
				}
			}

			psInsert.close();
			ps.close();
			rs.close();

		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	/**
	 * Remove records in shared jobs table for users who have been denied access
	 * because their user group has been denied access
	 *
	 * @param conn
	 * @param jId
	 * @param groupId
	 */
	public void removeSharedJobUsers(Connection conn, int jId, int groupId) {
		String sql;
		PreparedStatement ps;
		ResultSet rs;
		PreparedStatement psDelete;

		try {
			//get users who should be denied access to the job because their group has been denied access
			sql = "SELECT ASJ.USERNAME "
					+ " FROM ART_SHARED_JOBS ASJ, ART_USER_GROUP_JOBS AUGJ "
					+ " WHERE ASJ.JOB_ID = AUGJ.JOB_ID "
					+ " AND ASJ.JOB_ID = ? "
					+ " AND EXISTS "
					+ " (SELECT * FROM ART_USER_GROUP_ASSIGNMENT AUGA "
					+ " WHERE AUGA.USER_GROUP_ID=AUGJ.USER_GROUP_ID "
					+ " AND AUGJ.USER_GROUP_ID = ?)";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jId);
			ps.setInt(2, groupId);
			rs = ps.executeQuery();

			//delete records from the shared jobs table
			sql = "DELETE FROM ART_SHARED_JOBS WHERE JOB_ID = ? AND USERNAME = ?";
			psDelete = conn.prepareStatement(sql);
			while (rs.next()) {
				try {
					psDelete.setInt(1, jId);
					psDelete.setString(2, rs.getString("USERNAME"));
					psDelete.executeUpdate();
				} catch (Exception e) {
					logger.error("Error. Job id {}", jId, e);
				}
			}
			psDelete.close();
			ps.close();
			rs.close();

		} catch (Exception e) {
			logger.error("Error. Job id={}, Group id={}", new Object[]{jId, groupId, e});
		}
	}

	/**
	 * Set timestamps in ART_JOBS table before job execution
	 */
	private void beforeExecution(Connection conn) {
		try {
			java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

			// Update LAST_START_DATE and next run date on ART_JOBS table
			String SQLUpdate = "UPDATE ART_JOBS SET LAST_START_DATE = ?, NEXT_RUN_DATE = ? WHERE JOB_ID = ?";
			PreparedStatement psUpdate = conn.prepareStatement(SQLUpdate);
			psUpdate.setTimestamp(1, now);
			if (nextRunDate != null) {
				psUpdate.setTimestamp(2, new java.sql.Timestamp(nextRunDate.getTime()));
			} else {
				psUpdate.setTimestamp(2, null);
			}
			psUpdate.setInt(3, jobId);
			psUpdate.executeUpdate();
			psUpdate.close();
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	//create job audit record
	private void createAuditRecord(Connection conn, String user) {
		try {
			if (StringUtils.equals(enableAudit, "Y")) {
				//generate unique key for this job run
				jobAuditKey = generateKey();

				String sqlString;
				PreparedStatement psUpdate;
				java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

				//insert job start audit values.
				sqlString = "INSERT INTO ART_JOBS_AUDIT (JOB_ID, JOB_ACTION, JOB_AUDIT_KEY, START_DATE, USERNAME) VALUES (?, 'S', ?, ?, ?)";
				psUpdate = conn.prepareStatement(sqlString);

				psUpdate.setInt(1, jobId);
				psUpdate.setString(2, jobAuditKey);
				psUpdate.setTimestamp(3, now);
				psUpdate.setString(4, user);
				psUpdate.executeUpdate();

				psUpdate.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	//set final end time and file name of job table
	private void afterCompletion(Connection conn) {
		try {
			java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

			String sqlString;
			PreparedStatement psUpdate;
			String finalFileName;

			String sep = java.io.File.separator;
			// if afterExecutionOnException was executed fileName contains the exception text and starts with -
			if (fileName.startsWith("-")) {
				finalFileName = fileName;
			} else {
				finalFileName = fileName.substring(fileName.lastIndexOf(sep) + 1); // only filename
			}
			// make sure we do not exceed the table col limit
			if (finalFileName.length() > 4000) {
				finalFileName = finalFileName.substring(0, 4000);
			}

			sqlString = "UPDATE ART_JOBS SET LAST_END_DATE = ?, LAST_FILE_NAME = ? WHERE JOB_ID = ?";
			psUpdate = conn.prepareStatement(sqlString);

			psUpdate.setTimestamp(1, now);
			psUpdate.setString(2, finalFileName);
			psUpdate.setInt(3, jobId);
			psUpdate.executeUpdate();

			psUpdate.close();
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	/**
	 * Set timestamps in ART_JOBS table after job execution If Audit Flag is
	 * set, a new row is added to ART_JOBS_AUDIT table
	 */
	private void afterExecution(Connection conn, boolean singleOutput, String user) {
		try {
			java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

			//Update LAST_END_DATE and FILENAME in ART_JOBS table
			//for shared users, update the shared jobs table
			String sqlString;
			PreparedStatement psShared;
			PreparedStatement psAudit;
			String finalFileName;

			String sep = java.io.File.separator;
			finalFileName = fileName.substring(fileName.lastIndexOf(sep) + 1); // only filename
			if (finalFileName.length() > 4000) {
				finalFileName = finalFileName.substring(0, 4000);
			}

			//no need to update jobs table for single output. aftercomplete will do the final update to the jobs table
			if (!singleOutput) {
				sqlString = "UPDATE ART_SHARED_JOBS SET LAST_FILE_NAME = ?, LAST_START_DATE = ?, LAST_END_DATE = ? "
						+ " WHERE JOB_ID = ? AND USERNAME = ?";
				psShared = conn.prepareStatement(sqlString);

				psShared.setString(1, finalFileName);
				psShared.setTimestamp(2, jobStartDate);
				psShared.setTimestamp(3, now);
				psShared.setInt(4, jobId);
				psShared.setString(5, user);
				psShared.executeUpdate();
				psShared.close();
			}

			//update audit table if required
			if (StringUtils.equals(enableAudit, "Y")) {
				sqlString = "UPDATE ART_JOBS_AUDIT SET JOB_ACTION = 'E', END_DATE = ? WHERE JOB_AUDIT_KEY = ? AND JOB_ID = ?";
				psAudit = conn.prepareStatement(sqlString);
				psAudit.setTimestamp(1, now);
				psAudit.setString(2, jobAuditKey);
				psAudit.setInt(3, jobId);
				psAudit.executeUpdate();
				psAudit.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	/**
	 * Sets exception in ART_JOBS table after job execution If Audit Flag is
	 * set, a new row is added to ART_JOBS_AUDIT table
	 */
	private void afterExecutionOnException(Connection conn, Exception ex, boolean singleOutput, String user) {
		try {
			java.sql.Timestamp now = new java.sql.Timestamp(new java.util.Date().getTime());

			// Update LAST_END_DATE and FILENAME in ART_JOBS table
			//for shared users, update the shared jobs table
			String sqlString;
			PreparedStatement psShared;
			PreparedStatement psAudit;
			String exception;

			exception = "-<b>Error:</b> " + ex;
			//update filename variable for possible later use because of shared jobs
			if (exception.length() > 4000) {
				fileName = exception.substring(0, 4000);
			} else {
				fileName = exception;
			}

			//no need to update jobs table for single output. aftercomplete will do the final update to the jobs table
			if (!singleOutput) {
				sqlString = "UPDATE ART_SHARED_JOBS SET LAST_FILE_NAME = ?, LAST_START_DATE = ?, LAST_END_DATE = ? "
						+ " WHERE JOB_ID = ? AND USERNAME = ?";
				psShared = conn.prepareStatement(sqlString);

				psShared.setString(1, exception);
				psShared.setTimestamp(2, jobStartDate);
				psShared.setTimestamp(3, now);
				psShared.setInt(4, jobId);
				psShared.setString(5, user);
				psShared.executeUpdate();
				psShared.close();
			}

			//update audit table if required
			if (StringUtils.equals(enableAudit, "Y")) {
				sqlString = "UPDATE ART_JOBS_AUDIT SET JOB_ACTION = 'X' WHERE JOB_AUDIT_KEY = ? AND JOB_ID = ?";
				psAudit = conn.prepareStatement(sqlString);
				psAudit.setString(1, jobAuditKey);
				psAudit.setInt(2, jobId);
				psAudit.executeUpdate();
				psAudit.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		}
	}

	/**
	 * Save a job in the database. If the job id is set, updates the existing
	 * job. Otherwise a new job is created.
	 */
	public void save() {
		Connection conn = null;

		try {
			//if (DEBUG) System.err.println(sNAME + ": ArtJob save() " + jobId);
			logger.debug("ArtJob save() {}", jobId);

			conn = ArtDBCP.getConnection();

			// Allocate a new job id if job id is not set
			if (jobId == -1) {
				jobId = allocateNewId(conn);
			}

			String sql = "UPDATE ART_JOBS SET"
					+ "   QUERY_ID= ? ,  USERNAME = ? ,  OUTPUT_FORMAT = ? ,  JOB_TYPE = ? "
					+ " , JOB_MINUTE = ? ,  JOB_HOUR = ? ,  JOB_DAY = ? ,  JOB_WEEKDAY= ? ,  JOB_MONTH = ? "
					+ " , MAIL_TOS = ? ,  MAIL_FROM = ? ,  MESSAGE = ? ,  ENABLE_AUDIT = ? ,  ACTIVE_STATUS = ? , SUBJECT = ? "
					+ " , NEXT_RUN_DATE=?, START_DATE=?, END_DATE=?, MIGRATED_TO_QUARTZ=?, ALLOW_SHARING=?, ALLOW_SPLITTING=? "
					+ " , CACHED_TABLE_NAME =?, JOB_NAME=?, MAIL_CC=?, MAIL_BCC=?, RECIPIENTS_QUERY_ID=? "
					+ " WHERE JOB_ID = " + jobId;

			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, queryId);
			ps.setString(2, username);
			ps.setString(3, outputFormat);
			ps.setInt(4, jobType);
			ps.setString(5, minute);
			ps.setString(6, hour);
			ps.setString(7, day);
			ps.setString(8, weekday);
			ps.setString(9, month);
			ps.setString(10, tos);
			ps.setString(11, from);
			ps.setString(12, message);
			ps.setString(13, enableAudit);
			ps.setString(14, activeStatus);
			ps.setString(15, subject);

			if (nextRunDate != null) {
				ps.setTimestamp(16, new java.sql.Timestamp(nextRunDate.getTime()));
			} else {
				ps.setTimestamp(16, null);
			}

			if (startDate != null) {
				ps.setDate(17, new java.sql.Date(startDate.getTime()));
			} else {
				ps.setDate(17, null);
			}
			if (endDate != null) {
				ps.setDate(18, new java.sql.Date(endDate.getTime()));
			} else {
				ps.setDate(18, null);
			}

			ps.setString(19, migratedToQuartz);
			ps.setString(20, allowSharing);
			ps.setString(21, allowSplitting);
			ps.setString(22, cachedTableName);
			ps.setString(23, jobName);
			ps.setString(24, cc);
			ps.setString(25, bcc);
			ps.setInt(26, recipientsQueryId);

			ps.executeUpdate();
			ps.close();

			//save job parameters
			if (inlineParams != null && multiParams != null) {
				Iterator itInline = inlineParams.entrySet().iterator();
				String name, value;
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				while (itInline.hasNext()) {
					Map.Entry entry = (Map.Entry) itInline.next();
					name = (String) entry.getKey();
					value = (String) entry.getValue();
					ps.setInt(1, jobId);
					ps.setString(2, "I");
					ps.setString(3, name);
					ps.setString(4, value);
					ps.addBatch();
				}

				Iterator itMulti = multiParams.entrySet().iterator();
				String values[];
				while (itMulti.hasNext()) {
					Map.Entry entry = (Map.Entry) itMulti.next();
					name = (String) entry.getKey();
					values = (String[]) entry.getValue();
					for (int j = 0; j < values.length; j++) {
						ps.setInt(1, jobId);
						ps.setString(2, "M");
						ps.setString(3, name);
						ps.setString(4, values[j]);
						ps.addBatch();
					}
				}

				ps.executeBatch();
				ps.close();
			}

			//enable show parameters in job output
			if (showParameters) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showParams");
				ps.setString(4, "true");

				ps.executeUpdate();
				ps.close();
			}

			//enable show graph data in pdf output
			if (showGraphData) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphData");
				ps.setString(4, "true");

				ps.executeUpdate();
				ps.close();
			}

			//enable custom graph settings
			if (showGraphDataPoints) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphDataPoints");
				ps.setString(4, "true");

				ps.executeUpdate();
				ps.close();
			}
			if (showGraphLegend) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphLegend");
				ps.setString(4, "true");

				ps.executeUpdate();
				ps.close();
			}
			if (showGraphLabels) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_showGraphLabels");
				ps.setString(4, "true");

				ps.executeUpdate();
				ps.close();
			}
			if (StringUtils.isNotBlank(jobGraphOptions)) {
				sql = "INSERT INTO ART_JOBS_PARAMETERS (JOB_ID, PARAM_TYPE, PARAM_NAME, PARAM_VALUE) "
						+ " VALUES (?,?,?,?)";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, jobId);
				ps.setString(2, "O");
				ps.setString(3, "_graphOptions");
				ps.setString(4, jobGraphOptions);

				ps.executeUpdate();
				ps.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close(); // art repository
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Delete this Job. Remove a Job from the database. If the jobs has
	 * parameters, the parameters are removed as well. If the job is a cached
	 * result one, drop the cached table
	 */
	public void delete() {
		Connection conn = null;

		try {
			logger.debug("Attempting to delete Job Id {}", jobId);

			//delete records in quartz tables
			String jobName = "job" + jobId;
			String jobGroup = "jobGroup";
			String triggerName = "trigger" + jobId;
			String triggerGroup = "triggerGroup";

			org.quartz.Scheduler scheduler = ArtDBCP.getScheduler();
			if (scheduler != null) {
				scheduler.deleteJob(jobKey(jobName, jobGroup)); //delete job records
				scheduler.unscheduleJob(triggerKey(triggerName, triggerGroup)); //delete trigger records
			}

			//delete records from art tables
			conn = ArtDBCP.getConnection();

			String SQL = "DELETE FROM ART_JOBS WHERE JOB_ID = ? ";
			PreparedStatement ps = conn.prepareStatement(SQL);
			ps.setInt(1, jobId);

			if (ps.executeUpdate() == 1) { // job exists                
				logger.debug("Job Deleted: ", jobId);

				SQL = "DELETE FROM ART_JOBS_PARAMETERS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();

				//delete any shared jobs that may exist
				SQL = "DELETE FROM ART_SHARED_JOBS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();

				//delete user group-shared jobs records
				SQL = "DELETE FROM ART_USER_GROUP_JOBS WHERE JOB_ID = ? ";
				ps = conn.prepareStatement(SQL);
				ps.setInt(1, jobId);
				ps.executeUpdate();
			}
			ps.close();

			// Delete the Cached table if this job is a cache result one
			if (jobType == 9 || jobType == 10) {
				// Delete
				int targetDatabaseId = Integer.parseInt(outputFormat);
				Connection cacheDatabaseConnection = ArtDBCP.getConnection(targetDatabaseId);
				CachedResult cr = new CachedResult();
				cr.setTargetConnection(cacheDatabaseConnection);
				if (cachedTableName == null || cachedTableName.length() == 0) {
					cachedTableName = queryName + "_J" + jobId;
				}
				cr.setCachedTableName(cachedTableName);
				cr.drop();
				cacheDatabaseConnection.close();
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close(); // art repository
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}
	}

	/**
	 * Load an existing Job (to update/save/execute). An existing Job is loaded
	 * from the database. Use the getXyz methods to get current properties and
	 * setXyx method to modify properties; then save() to commit the changes on
	 * the database.
	 *
	 * @param jId
	 */
	public void load(int jId) {
		load(jId, username); // if username is not null this job is loaded only if the existing job username matches this job username
	}

	/**
	 *
	 * @param jId
	 * @param usr
	 */
	public void load(int jId, String usr) {
		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			logger.debug("Loading job. Job Id={}, User={}", jId, usr);

			String SQL = "SELECT aj.QUERY_ID, aj.USERNAME, aj.OUTPUT_FORMAT, aj.JOB_TYPE, aj.MAIL_TOS, aj.MAIL_FROM, aj.MESSAGE "
					+ "    , aj.JOB_MINUTE, aj.JOB_HOUR, aj.JOB_DAY, aj.JOB_WEEKDAY, aj.JOB_MONTH, aj.ENABLE_AUDIT , aj.ACTIVE_STATUS AS JOB_ACTIVE_STATUS , aj.SUBJECT "
					+ "    , aq.NAME AS QUERY_NAME, aq.QUERY_TYPE, aq.SHORT_DESCRIPTION, aq.X_AXIS_LABEL, aq.Y_AXIS_LABEL, aq.GRAPH_OPTIONS, aq.USES_RULES "
					+ "    , aj.ALLOW_SHARING, aj.ALLOW_SPLITTING, aj.MAIL_CC, aj.MAIL_BCC, aj.RECIPIENTS_QUERY_ID "
					+ "    , aj.NEXT_RUN_DATE, aj.START_DATE, aj.END_DATE, aj.MIGRATED_TO_QUARTZ, aq.ACTIVE_STATUS AS QUERY_ACTIVE_STATUS, aj.LAST_FILE_NAME "
					+ "    , aj.CACHED_TABLE_NAME, aj.JOB_NAME, au.ACTIVE_STATUS AS OWNER_ACTIVE_STATUS "
					+ " FROM ART_JOBS aj, ART_QUERIES aq, ART_USERS au"
					+ " WHERE aq.QUERY_ID = aj.QUERY_ID AND aj.USERNAME=au.USERNAME AND aj.JOB_ID = ? "
					+ (usr != null ? "  AND aj.USERNAME = ? " : "");

			PreparedStatement ps = conn.prepareStatement(SQL);
			ps.setInt(1, jId);

			if (usr != null) {
				ps.setString(2, usr);
			}

			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				logger.debug("Job Found: {}", jId);

				jobId = jId;
				setQueryId(rs.getInt("QUERY_ID"));
				setUsername(rs.getString("USERNAME"));
				setOutputFormat(rs.getString("OUTPUT_FORMAT"));
				setJobType(rs.getInt("JOB_TYPE"));
				setTos(rs.getString("MAIL_TOS"));
				setFrom(rs.getString("MAIL_FROM"));
				setMessage(rs.getString("MESSAGE"));
				setMinute(rs.getString("JOB_MINUTE"));
				setHour(rs.getString("JOB_HOUR"));
				setDay(rs.getString("JOB_DAY"));
				setWeekday(rs.getString("JOB_WEEKDAY"));
				setMonth(rs.getString("JOB_MONTH"));
				setEnableAudit(rs.getString("ENABLE_AUDIT"));
				setActiveStatus(rs.getString("JOB_ACTIVE_STATUS"));
				setSubject(rs.getString("SUBJECT"));
				setQueryName(rs.getString("QUERY_NAME"));
				setQueryType(rs.getInt("QUERY_TYPE"));

				//values to be used with charts
				queryShortDescription = rs.getString("SHORT_DESCRIPTION");
				xaxisLabel = rs.getString("X_AXIS_LABEL");
				yaxisLabel = rs.getString("Y_AXIS_LABEL");
				queryGraphOptions = rs.getString("GRAPH_OPTIONS");

				setNextRunDate(rs.getTimestamp("NEXT_RUN_DATE"));
				setStartDate(rs.getDate("START_DATE"));
				setEndDate(rs.getDate("END_DATE"));
				setMigratedToQuartz(rs.getString("MIGRATED_TO_QUARTZ"));
				setQueryStatus(rs.getString("QUERY_ACTIVE_STATUS"));
				setLastFileName(rs.getString("LAST_FILE_NAME"));
				setQueryRulesFlag(rs.getString("USES_RULES"));
				setAllowSharing(rs.getString("ALLOW_SHARING"));
				setAllowSplitting(rs.getString("ALLOW_SPLITTING"));
				setCachedTableName(rs.getString("CACHED_TABLE_NAME"));
				setJobName(rs.getString("JOB_NAME"));

				jobOwnerStatus = rs.getString("OWNER_ACTIVE_STATUS");
				cc = rs.getString("MAIL_CC");
				bcc = rs.getString("MAIL_BCC");
				recipientsQueryId = rs.getInt("RECIPIENTS_QUERY_ID");

				//update from address in case the user's email address has changed
				UserEntity ue = new UserEntity(username);
				String currentEmail = ue.getEmail();
				if (StringUtils.length(currentEmail) > 4) {
					setFrom(currentEmail);
				}
			}
		} catch (SQLException e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close(); // art repository
				}
			} catch (Exception e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

	}

	/**
	 * Reset Job attributes. This is used to "empty" an existing ArtJob object
	 * in order to re-use it to save another job. Used in editJob.jsp to make
	 * sure a cached ArtJob is not considered when creating a new schduled job
	 */
	public void reset() {
		jobId = -1;
		queryType = 0;
		queryId = -1;
		outputFormat = null;
		tos = null;
		message = null;
		subject = null;
		cachedTableName = null;
	}

	/**
	 *
	 * @param hashInline
	 * @param hashMulti
	 */
	public void setParameters(Map<String, String> hashInline, Map<String, String[]> hashMulti) {
		inlineParams = hashInline;
		multiParams = hashMulti;
	}

	public void buildParameters() {
		buildParameters(queryId);
	}

	/**
	 * Build job parameters
	 */
	public void buildParameters(int qId) {

		Connection conn = null;

		try {
			//Collect the parameters from the database
			multiParams = null;
			inlineParams = null;
			displayParams = null;
			htmlParams = null;

			multiParams = new HashMap<String, String[]>();
			inlineParams = new HashMap<String, String>();

			ArtQuery aq = new ArtQuery();
			htmlParams = aq.getHtmlParams(qId);

			conn = ArtDBCP.getConnection();

			Statement st = conn.createStatement();
			String SQL = "SELECT PARAM_TYPE, PARAM_NAME, PARAM_VALUE FROM ART_JOBS_PARAMETERS "
					+ " WHERE JOB_ID = " + jobId + " ORDER BY PARAM_TYPE, PARAM_NAME";

			ResultSet rs = st.executeQuery(SQL);

			StringArray sa = new StringArray();
			String name;

			int paramCount = 0;
			String paramType;
			String paramName;
			String paramValue;

			StringBuilder sb = new StringBuilder(1024 * 2);
			sb.append("<br><i>Parameters:</i><br>");

			//put the parameters in maps
			while (rs.next()) {
				paramCount++;

				paramType = rs.getString("PARAM_TYPE");
				paramName = rs.getString("PARAM_NAME");
				paramValue = rs.getString("PARAM_VALUE");

				//set display string
				sb.append("<b>");
				sb.append(paramName);
				sb.append(":</b>&nbsp;");
				sb.append(paramValue);
				sb.append("<br>");

				//build hash tables
				if (StringUtils.equals(paramType, "I")) {
					inlineParams.put(paramName, paramValue);

					//set parameter value in htmlparams map
					ArtQueryParam aqp = htmlParams.get("P_" + paramName);
					if (aqp != null) {
						aqp.setParamValue(paramValue);
					}
				} else if (StringUtils.equals(paramType, "M")) {
					name = paramName;
					sa.add(paramValue);
					while (rs.next()) {
						logger.debug("Job Id {}. Multi parameter: {}", jobId, name);

						paramName = rs.getString("PARAM_NAME");
						paramValue = rs.getString("PARAM_VALUE");

						sb.append("<b>");
						sb.append(paramName);
						sb.append(":</b>&nbsp;");
						sb.append(paramValue);
						sb.append("<br>");

						if (paramName.equals(name)) {
							sa.add(paramValue);
						} else {
							logger.debug("Job Id {}. Adding Multi to Hash: {}", jobId, name);

							multiParams.put(name, sa.getStringArray());
							name = paramName;
							sa = new StringArray();
							sa.add(paramValue);
						}
					}

					logger.debug("Job Id {}. Adding Multi to Hash: {}", jobId, name);
					if (logger.isDebugEnabled()) {
						for (int i = 0; i < sa.length(); i++) {
							logger.debug("Job Id {}. Value: {}", sa.get(i));
						}
					}

					String[] paramValues = sa.getStringArray();
					multiParams.put(name, paramValues);

					//set parameter value in htmlparams map
					ArtQueryParam aqp = htmlParams.get("M_" + paramName);
					if (aqp != null) {
						aqp.setParamValue(paramValues);
					}
				} else if (StringUtils.equals(paramType, "O")) {
					//other parameters					
					if (StringUtils.equals(paramName, "_showParams")) {
						//enable display of parameters in output
						showParameters = true;
					} else if (StringUtils.equals(paramName, "_showGraphData")) {
						//enable display of graph data in pdf graph output
						showGraphData = true;
					} else if (StringUtils.equals(paramName, "_showGraphDataPoints")) {
						//enable display of graph data points
						showGraphDataPoints = true;
					} else if (StringUtils.equals(paramName, "_showGraphLegend")) {
						//enable display of graph legend
						showGraphLegend = true;
					} else if (StringUtils.equals(paramName, "_showGraphLabels")) {
						//enable display of graph labels
						showGraphLabels = true;
					} else if (StringUtils.equals(paramName, "_graphOptions")) {
						//enable use of custom graph options
						jobGraphOptions = paramValue;
					}
				}
			}
			rs.close();
			st.close();

			if (paramCount == 0) {
				parametersDisplayString = "";
			} else {
				parametersDisplayString = sb.toString();
			}

			//enable show parameters in job output            
			if (showParameters) {
				displayParams = new TreeMap<Integer, ArtQueryParam>();

				Iterator it;
				String htmlName;
				String value;
				String label;
				it = inlineParams.entrySet().iterator();
				while (it.hasNext()) {
					Map.Entry entry = (Map.Entry) it.next();
					label = (String) entry.getKey();
					htmlName = "P_" + label;
					value = (String) entry.getValue();

					ArtQueryParam param = htmlParams.get(htmlName);
					if (param != null) {
						//for dynamic date values e.g. ADD... ensure what is used to execute the query is same as what is displayed
						String paramDataType = param.getParamDataType();
						if (StringUtils.startsWith(paramDataType, "DATE")) {
							String dateFormat;
							if (paramDataType.equals("DATE")) {
								dateFormat = "yyyy-MM-dd";
							} else {
								dateFormat = "yyyy-MM-dd HH:mm:ss";
							}
							java.util.Date defaultDate = PreparedQuery.getDefaultValueDate(value);
							SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);
							value = dateFormatter.format(defaultDate);

							//update inline param
							inlineParams.put(label, value);
						}
						param.setParamValue(value);

						//for lov parameters, show both parameter value and friendly value
						if (param.usesLov()) {
							//get all possible lov values.							
							try {
								PreparedQuery pq = new PreparedQuery();
								pq.setQueryId(param.getLovQueryId());
								Map<String, String> lov = pq.executeLovQuery(false); //don't apply rules
								param.setLovValues(lov);
							} catch (Exception e) {
								logger.error("Error", e);
							}
						}
						displayParams.put(param.getFieldPosition(), param);
					}

				}

				String[] values;
				it = multiParams.entrySet().iterator();
				while (it.hasNext()) {
					Map.Entry entry = (Map.Entry) it.next();
					htmlName = "M_" + (String) entry.getKey();
					values = (String[]) entry.getValue();

					ArtQueryParam param = htmlParams.get(htmlName);
					if (param != null) {
						param.setParamValue(values);

						//for lov parameters, show both parameter value and friendly value
						if (param.usesLov()) {
							//get all possible lov values.							
							try {
								PreparedQuery pq = new PreparedQuery();
								pq.setQueryId(param.getLovQueryId());
								Map<String, String> lov = pq.executeLovQuery(false); //don't apply rules
								param.setLovValues(lov);
							} catch (Exception e) {
								logger.error("Error", e);
							}
						}

						displayParams.put(param.getFieldPosition(), param);
					}

				}
			}
		} catch (Exception e) {
			logger.error("Error. Job id {}", jobId, e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error. Job id {}", jobId, e);
			}
		}

	}

	private PreparedQuery prepareQuery(String user) throws SQLException {
		return prepareQuery(user, queryId, true);
	}

	/**
	 * Prepares a job for its execution Loads additional info needed to execute
	 * (immediately) the job (query id, datasource etc).
	 */
	private PreparedQuery prepareQuery(String user, int qId, boolean buildParams) throws SQLException {
		logger.debug("Job Id {}. prepare()", jobId);

		//build parameter objects from parameters saved in the database
		if (buildParams) {
			buildParameters(qId);
		}

		PreparedQuery pq = new PreparedQuery();
		pq.setUsername(user);
		pq.setQueryId(qId);
		pq.setAdminSession(false);
		pq.setInlineParams(inlineParams);
		pq.setMultiParams(multiParams);
		pq.setHtmlParams(htmlParams);

		logger.debug("Job Id {}. prepare() finished", jobId);

		return pq;

	}

	private synchronized int allocateNewId(Connection conn) throws SQLException {
		// Get the id
		Statement st = conn.createStatement();
		ResultSet rs = st.executeQuery("SELECT MAX(JOB_ID) FROM ART_JOBS");
		int newJobId = 1;
		if (rs.next()) {
			newJobId = 1 + rs.getInt(1);
		} else {
			logger.warn("Job allocateNewJobId failed. Defaulting to 1");
		}
		rs.close();
		st.close();

		//Allocating First
		Statement stUpdate = conn.createStatement();
		stUpdate.executeUpdate("INSERT INTO ART_JOBS (JOB_ID, QUERY_ID, USERNAME, OUTPUT_FORMAT, JOB_TYPE, ACTIVE_STATUS, ENABLE_AUDIT, MIGRATED_TO_QUARTZ) "
				+ " VALUES (" + newJobId + ",0,'allocating','html',1, 'Y','N','X') ");
		stUpdate.close();

		return newJobId;
	}

	private Mailer getMailer() {
		String smtpServer = ArtDBCP.getArtSetting("smtp_server");
		String smtpUsername = ArtDBCP.getArtSetting("smtp_username");
		String smtpPassword = ArtDBCP.getArtSetting("smtp_password");

		Mailer m = new Mailer();
		m.setSmtpHost(smtpServer);
		if (StringUtils.length(smtpUsername) > 3 && smtpPassword != null) {
			m.setUsername(smtpUsername);
			smtpPassword = Encrypter.decrypt(smtpPassword);
			m.setPassword(smtpPassword);
		}

		//pass secure smtp mechanism and smtp port, in case they are required
		m.setSmtpPort(ArtDBCP.getArtSetting("smtp_port"));
		m.setSecureSmtp(ArtDBCP.getArtSetting("secure_smtp"));

		return m;
	}

	/**
	 * Migrate existing jobs created in art versions before 1.11 to quartz jobs
	 *
	 */
	public void migrateJobsToQuartz() {

		Connection conn = ArtDBCP.getConnection();
		org.quartz.Scheduler scheduler = ArtDBCP.getScheduler();

		if (conn == null) {
			logger.info("Can't migrate jobs to Quartz. Connection to ART repository not available");
		} else if (scheduler == null) {
			logger.info("Can't migrate jobs to Quartz. Scheduler not available");
		}

		if (scheduler == null || conn == null) {
			return;
		}

		try {
			String oldJobsSqlString;
			String updateJobSqlString;
			PreparedStatement psUpdate;

			//prepare statement for updating migration status			
			updateJobSqlString = "UPDATE ART_JOBS SET MIGRATED_TO_QUARTZ='Y', NEXT_RUN_DATE=? "
					+ ", JOB_MINUTE=?, JOB_HOUR=?, JOB_DAY=?, JOB_WEEKDAY=?, JOB_MONTH=? "
					+ " WHERE JOB_ID=?";
			psUpdate = conn.prepareStatement(updateJobSqlString);

			//determine the jobs to migrate
			oldJobsSqlString = "SELECT JOB_ID, JOB_MINUTE, JOB_HOUR, JOB_DAY, JOB_WEEKDAY, JOB_MONTH FROM ART_JOBS WHERE MIGRATED_TO_QUARTZ='N'";

			PreparedStatement ps = conn.prepareStatement(oldJobsSqlString);
			ResultSet rs = ps.executeQuery();

			String minute;
			String hour;
			String day;
			String weekday;
			String month;
			String second = "0"; //seconds always 0
			String cronString;
			java.util.Date nextRunDate;

			int jobId;
			String jobName;
			String jobGroup = "jobGroup";
			String triggerName;
			String triggerGroup = "triggerGroup";

			int totalRecordCount = 0; //total number of jobs to be migrated
			int migratedRecordCount = 0; //actual number of jobs migrated
			final int batchSize = 100; //max number of updates to batch together for executebatch

			while (rs.next()) {
				totalRecordCount += 1;

				//create quartz job
				minute = rs.getString("JOB_MINUTE");
				if (minute == null) {
					minute = "0"; //default to 0
				}
				hour = rs.getString("JOB_HOUR");
				if (hour == null) {
					hour = "3"; //default to 3am
				}
				month = rs.getString("JOB_MONTH");
				if (month == null) {
					month = "*"; //default to every month
				}
				//set day and weekday
				day = rs.getString("JOB_DAY");
				if (day == null) {
					day = "*";
				}
				weekday = rs.getString("JOB_WEEKDAY");
				if (weekday == null) {
					weekday = "?";
				}

				//set default day of the month if weekday is defined
				if (day.length() == 0 && weekday.length() >= 1 && !weekday.equals("?")) {
					//weekday defined but day of the month is not. default day to ?
					day = "?";
				}

				if (day.length() == 0) {
					//no day of month defined. default to *
					day = "*";
				}
				if (weekday.length() == 0) {
					//no day of week defined. default to undefined
					weekday = "?";
				}
				if (day.equals("?") && weekday.equals("?")) {
					//unsupported. only one can be ?
					day = "*";
					weekday = "?";
				}
				if (day.equals("*") && weekday.equals("*")) {
					//unsupported. only one can be defined
					day = "*";
					weekday = "?";
				}

				cronString = second + " " + minute + " " + hour + " " + day + " " + month + " " + weekday;
				if (CronExpression.isValidExpression(cronString)) {
					//ensure that trigger will fire at least once in the future
					CronTrigger tempTrigger = newTrigger().withSchedule(cronSchedule(cronString)).build();

					nextRunDate = tempTrigger.getFireTimeAfter(new java.util.Date());
					if (nextRunDate != null) {
						//create job
						migratedRecordCount += 1;
						if (migratedRecordCount == 1) {
							logger.info("Migrating jobs to quartz...");
						}

						jobId = rs.getInt("JOB_ID");
						jobName = "job" + jobId;
						triggerName = "trigger" + jobId;

						JobDetail quartzJob = newJob(ArtJob.class).withIdentity(jobName, jobGroup).usingJobData("jobid", jobId).build();

						//create trigger that defines the schedule for the job						
						CronTrigger trigger = newTrigger().withIdentity(triggerName, triggerGroup).withSchedule(cronSchedule(cronString)).build();


						//delete any existing jobs or triggers with the same id before adding them to the scheduler
						scheduler.deleteJob(jobKey(jobName, jobGroup)); //delete job records
						scheduler.unscheduleJob(triggerKey(triggerName, triggerGroup)); //delete any trigger records

						//add job and trigger to scheduler
						scheduler.scheduleJob(quartzJob, trigger);

						//update jobs table to indicate that the job has been migrated						
						psUpdate.setTimestamp(1, new java.sql.Timestamp(nextRunDate.getTime()));
						psUpdate.setString(2, minute);
						psUpdate.setString(3, hour);
						psUpdate.setString(4, day);
						psUpdate.setString(5, weekday);
						psUpdate.setString(6, month);
						psUpdate.setInt(7, jobId);

						psUpdate.addBatch();

						//run executebatch periodically to prevent out of memory errors
						if (migratedRecordCount % batchSize == 0) {
							ps.executeBatch();
							ps.clearBatch(); //not sure if this is necessary
						}
					}
				}
			}
			if (migratedRecordCount > 0) {
				psUpdate.executeBatch(); //run any remaining updates																
			}
			psUpdate.close();

			rs.close();
			ps.close();

			if (migratedRecordCount > 0) {
				//output the number of jobs migrated
				logger.info("Finished migrating jobs to quartz. Migrated {} out of {} jobs", migratedRecordCount, totalRecordCount);
			}
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to users
	 *
	 * @param action
	 * @param users
	 */
	public void updateUserAccess(String action, String[] users) {

		if (action == null || users == null) {
			return;
		}

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_SHARED_JOBS (USERNAME,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_SHARED_JOBS WHERE USERNAME = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < users.length; i++) {
				ps.setString(1, users[i]);
				ps.setInt(2, jobId);
				try {
					ps.executeUpdate();
				} catch (SQLIntegrityConstraintViolationException e) {
					logger.info("Access to Job ID {} already granted to User {}", jobId, users[i]);
				} catch (SQLException e) {
					logger.warn("Error. Job id={}, User={}", new Object[]{jobId, users[i], e});
				}
			}
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to users
	 *
	 * @param action
	 * @param users
	 * @param jobs
	 */
	public void updateUserAccess(String action, String[] users, String[] jobs) {

		if (action == null || users == null || jobs == null) {
			return;
		}

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_SHARED_JOBS (USERNAME, JOB_ID) values (? , ? )";
			} else {
				sql = "DELETE FROM ART_SHARED_JOBS WHERE USERNAME = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < jobs.length; i++) {
				for (int j = 0; j < users.length; j++) {
					ps.setString(1, users[j]);
					ps.setInt(2, Integer.parseInt(jobs[i]));
					try {
						ps.executeUpdate();
					} catch (SQLIntegrityConstraintViolationException e) {
						logger.info("Access to Job ID {} already granted to User {}", jobId, users[i]);
					} catch (SQLException e) {
						logger.warn("Error. Job id={}, User={}", new Object[]{jobs[i], users[j], e});
					}
				}
			}
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

	}

	/**
	 * Grant or revoke access to user groups
	 *
	 * @param action
	 * @param groups
	 */
	public void updateUserGroupAccess(String action, String[] groups) {

		if (action == null || groups == null) {
			return;
		}

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_GROUP_JOBS (USER_GROUP_ID,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_USER_GROUP_JOBS WHERE USER_GROUP_ID = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < groups.length; i++) {
				ps.setInt(1, Integer.parseInt(groups[i]));
				ps.setInt(2, jobId);
				try {
					ps.executeUpdate();
				} catch (SQLIntegrityConstraintViolationException e) {
					logger.info("Access to Job ID {} already granted to User Group ID {}", jobId, groups[i]);
				} catch (SQLException e) {
					logger.warn("Error. Job id={}, Group id={}", new Object[]{jobId, groups[i], e});
				}
			}
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Grant or revoke access to user groups
	 *
	 * @param action
	 * @param groups
	 * @param jobs
	 */
	public void updateUserGroupAccess(String action, String[] groups, String[] jobs) {

		if (action == null || groups == null || jobs == null) {
			return;
		}

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;

			if (action.equals("GRANT")) {
				sql = "INSERT INTO ART_USER_GROUP_JOBS (USER_GROUP_ID,JOB_ID) VALUES(?, ?)";
			} else {
				sql = "DELETE FROM ART_USER_GROUP_JOBS WHERE USER_GROUP_ID = ? AND JOB_ID = ?";
			}

			ps = conn.prepareStatement(sql);

			for (int i = 0; i < jobs.length; i++) {
				for (int j = 0; j < groups.length; j++) {
					//remove records in shared jobs table for users who have been denied access because their user group has been denied access
					//must be done before the job group record is deleted
					if (action.equals("REVOKE")) {
						removeSharedJobUsers(conn, Integer.parseInt(jobs[i]), Integer.parseInt(groups[j]));
					}

					ps.setInt(1, Integer.parseInt(groups[j]));
					ps.setInt(2, Integer.parseInt(jobs[i]));
					try {
						ps.executeUpdate();
					} catch (SQLIntegrityConstraintViolationException e) {
						logger.info("Access to Job ID {} already granted to User Group ID {}", jobs[i], groups[j]);
					} catch (SQLException e) {
						logger.warn("Error. Job id={}, Group id={}", new Object[]{jobs[i], groups[j], e});
					}
				}
			}
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}
	}

	/**
	 * Get an indicator of jobs and the users and user groups they have been
	 * shared with
	 *
	 * @return jobs and the users and user groups they have been shared with
	 */
	public Map<Integer, String> getSharedJobAssignment() {
		TreeMap<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;
			Integer count = 0; //to ensure items are displayed starting with users then user groups

			//get jobs which have been shared with users
			sql = "SELECT ASJ.USERNAME, AJ.JOB_ID, AJ.JOB_NAME "
					+ " FROM ART_SHARED_JOBS ASJ, ART_JOBS AJ "
					+ " WHERE ASJ.JOB_ID=AJ.JOB_ID "
					+ " ORDER BY ASJ.USERNAME";

			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("USERNAME") + " - " + "Job " + rs.getInt("JOB_ID") + " (" + rs.getString("JOB_NAME") + ")";
				map.put(count, tmp);
			}
			rs.close();
			ps.close();

			//get jobs which have been shared with user groups
			sql = "SELECT AUG.NAME, AJ.JOB_ID, AJ.JOB_NAME "
					+ " FROM ART_USER_GROUP_JOBS AUGJ, ART_USER_GROUPS AUG, ART_JOBS AJ "
					+ " WHERE AUGJ.USER_GROUP_ID=AUG.USER_GROUP_ID "
					+ " AND AUGJ.JOB_ID=AJ.JOB_ID "
					+ " ORDER BY AUG.NAME";

			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = "[" + rs.getString("NAME") + "] - " + "Job " + rs.getInt("JOB_ID") + " (" + rs.getString("JOB_NAME") + ")";
				map.put(count, tmp);
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

		return map;
	}

	//get emails for shared job users
	private String getSharedJobEmails() {
		String emails = "";

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;

			//get emails from shared job groups
			sql = "SELECT DISTINCT AU.EMAIL "
					+ " FROM ART_USER_GROUP_JOBS AUGJ, ART_USER_GROUP_ASSIGNMENT AUGA, ART_USERS AU "
					+ " WHERE AUGJ.USER_GROUP_ID=AUGA.USER_GROUP_ID AND AUGA.USERNAME=AU.USERNAME "
					+ " AND AUGJ.JOB_ID=?";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);

			rs = ps.executeQuery();
			while (rs.next()) {
				tmp = rs.getString("EMAIL");
				if (StringUtils.length(tmp) > 4) {
					emails = emails + tmp + ";";
				}
			}
			rs.close();
			ps.close();

			//get emails from shared users
			sql = " SELECT DISTINCT AU.EMAIL "
					+ " FROM ART_SHARED_JOBS ASJ, ART_USERS AU "
					+ " WHERE ASJ.USERNAME=AU.USERNAME "
					+ " AND ASJ.JOB_ID=?";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				tmp = rs.getString("EMAIL");
				if (StringUtils.length(tmp) > 4) {
					emails = emails + tmp + ";";
				}
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (SQLException e) {
				logger.error("Error", e);
			}
		}

		emails = emails + tos;

		return emails;
	}

	/**
	 * Get an indicator of which users this job has been shared with
	 *
	 * @return an indicator of which users this job has been shared with
	 */
	public Map getSharedUsers() {
		TreeMap<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;
			Integer count = 0;

			sql = "SELECT DISTINCT USERNAME "
					+ " FROM ART_SHARED_JOBS "
					+ " WHERE JOB_ID=? "
					+ " ORDER BY USERNAME";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("USERNAME");
				map.put(count, tmp);
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}

		return map;
	}

	/**
	 * Get an indicator of which user groups this job has been shared with
	 *
	 * @return an indicator of which user groups this job has been shared with
	 */
	public Map getSharedUserGroups() {
		TreeMap<Integer, String> map = new TreeMap<Integer, String>();

		Connection conn = null;

		try {
			conn = ArtDBCP.getConnection();

			String sql;
			PreparedStatement ps;
			ResultSet rs;
			String tmp;
			Integer count = 0;

			sql = "SELECT DISTINCT aug.NAME "
					+ " FROM ART_USER_GROUP_JOBS augj, ART_USER_GROUPS aug "
					+ " WHERE augj.USER_GROUP_ID=aug.USER_GROUP_ID"
					+ " AND augj.JOB_ID=? "
					+ " ORDER BY aug.NAME";

			ps = conn.prepareStatement(sql);
			ps.setInt(1, jobId);
			rs = ps.executeQuery();
			while (rs.next()) {
				count++;
				tmp = rs.getString("NAME");
				map.put(count, tmp);
			}
			rs.close();
			ps.close();
		} catch (Exception e) {
			logger.error("Error", e);
		} finally {
			try {
				if (conn != null) {
					conn.close();
				}
			} catch (Exception e) {
				logger.error("Error", e);
			}
		}

		return map;
	}
}
